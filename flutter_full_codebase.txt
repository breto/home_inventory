FLUTTER PROJECT CODEBASE BUNDLE
Generated for Gemini Analysis


============================================================
PATH: .\analysis_options.yaml
============================================================

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


============================================================
PATH: .\devtools_options.yaml
============================================================

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:


============================================================
PATH: .\pubspec.yaml
============================================================

name: home_inventory
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.8

# Section 1: Packages your app NEEDS to run
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.1.1
  sqflite: ^2.3.0
  path: ^1.8.3
  image_picker: ^1.0.4
  path_provider: ^2.1.1
  intl: ^0.20.2
  archive: ^4.0.7
  share_plus: ^12.0.1
  shared_preferences: ^2.5.4
  pdf: ^3.10.7
  printing: ^5.11.1
  flutter_image_compress: ^2.3.0
  mobile_scanner: ^5.2.0
  file_picker: ^8.0.0
  csv: ^5.0.2
  speech_to_text: ^7.0.0
  camera: ^0.10.5+5
  permission_handler: ^11.0.0
  flutter_speed_dial: ^7.0.0

# Section 2: Tools for you (the developer) only
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true

============================================================
PATH: .\lib\main.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'providers/inventory_provider.dart';
import 'providers/settings_provider.dart'; // New Import
import 'screens/home_screen.dart';

void main() async {
  // Ensure Flutter is initialized before loading SharedPreferences
  WidgetsFlutterBinding.ensureInitialized();

  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        // Load Inventory Data
        ChangeNotifierProvider(
          create: (context) => InventoryProvider()..initializeData(),
        ),
        // Load Insurance Profile & Theme Settings
        ChangeNotifierProvider(
          create: (context) => SettingsProvider(),
        ),
      ],
      child: Consumer<SettingsProvider>(
        builder: (context, settings, child) {
          return MaterialApp(
            title: 'Home Inventory',
            debugShowCheckedModeBanner: false,
            // Standard Light Theme
            theme: ThemeData(
              colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
              useMaterial3: true,
            ),
            // Dark Theme Configuration
            darkTheme: ThemeData(
              colorScheme: ColorScheme.fromSeed(
                seedColor: Colors.blue,
                brightness: Brightness.dark,
              ),
              useMaterial3: true,
            ),
            // This line tells the app which mode to use based on your Settings Screen
            themeMode: settings.themeMode,
            home: const HomeScreen(),
          );
        },
      ),
    );
  }
}

============================================================
PATH: .\lib\data\database_helper.dart
============================================================

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/item.dart';
import 'dart:developer' as dev;
import '../services/logger_service.dart'; // Import your new logger

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  static const String _dbName = 'inventory.db';
  static const int _dbVersion = 5;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB(_dbName);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    logger.log("Initializing Database at path: $path");

    try {
      return await openDatabase(
        path,
        version: _dbVersion,
        onCreate: _createDB,
        onUpgrade: _onUpgrade,
      );
    } catch (e) {
      logger.log("CRITICAL: Database open failed", error: e);
      rethrow;
    }
  }

  Future _createDB(Database db, int version) async {
    logger.log("Creating new Database version: $version");

    await db.execute('''
      CREATE TABLE items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        value REAL NOT NULL,
        purchaseDate TEXT NOT NULL,
        warrantyExpiry TEXT,
        imagePaths TEXT NOT NULL,
        receiptIndices TEXT,
        room TEXT,
        category TEXT,
        serialNumber TEXT,
        brand TEXT,
        model TEXT,
        notes TEXT
      )
    ''');

    await db.execute('CREATE TABLE rooms (name TEXT PRIMARY KEY)');
    await db.execute('CREATE TABLE categories (name TEXT PRIMARY KEY)');

    // Seed Data
    final rooms = ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
    for (var r in rooms) await db.insert('rooms', {'name': r});

    final cats = ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];
    for (var c in cats) await db.insert('categories', {'name': c});

    logger.log("Database tables created and seeded with default rooms/categories.");
  }

  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    logger.log("DATABASE UPGRADE: Migrating from $oldVersion to $newVersion");
    if (oldVersion < 5) {
      try {
        await db.execute('ALTER TABLE items ADD COLUMN warrantyExpiry TEXT');
        await db.execute('ALTER TABLE items ADD COLUMN receiptIndices TEXT');
        logger.log("Migration successful: Added warranty and receipt columns.");
      } catch (e) {
        logger.log("Migration Note: Columns might already exist.", error: e);
      }
    }
  }

  // --- CRUD OPERATIONS ---

  Future<Item> create(Item item) async {
    try {
      final db = await instance.database;
      final id = await db.insert('items', item.toMap());
      logger.log("DB: Created item '${item.name}' with ID: $id");
      return item.copyWith(id: id);
    } catch (e) {
      logger.log("DB ERROR: Create failed for '${item.name}'", error: e);
      rethrow;
    }
  }

  Future<List<Item>> readAllItems() async {
    try {
      final db = await instance.database;
      final result = await db.query('items', orderBy: 'name ASC');
      logger.log("DB: Fetched ${result.length} items.");
      return result.map((json) => Item.fromMap(json)).toList();
    } catch (e) {
      logger.log("DB ERROR: ReadAllItems failed", error: e);
      return [];
    }
  }

  Future<int> update(Item item) async {
    try {
      final db = await instance.database;
      final rowsAffected = await db.update(
        'items',
        item.toMap(),
        where: 'id = ?',
        whereArgs: [item.id],
      );
      logger.log("DB: Updated item ID ${item.id}. Rows affected: $rowsAffected");
      return rowsAffected;
    } catch (e) {
      logger.log("DB ERROR: Update failed for ID ${item.id}", error: e);
      rethrow;
    }
  }

  Future<int> delete(int id) async {
    try {
      final db = await instance.database;
      final rowsAffected = await db.delete('items', where: 'id = ?', whereArgs: [id]);
      logger.log("DB: Deleted item ID $id. Rows affected: $rowsAffected");
      return rowsAffected;
    } catch (e) {
      logger.log("DB ERROR: Delete failed for ID $id", error: e);
      rethrow;
    }
  }

  Future<int> deleteAllItems() async {
    try {
      final db = await instance.database;
      final count = await db.delete('items');
      logger.log("DB: CLEARED ALL ITEMS. $count rows removed.");
      return count;
    } catch (e) {
      logger.log("DB ERROR: DeleteAllItems failed", error: e);
      rethrow;
    }
  }

  // --- LIST HELPERS ---

  Future<List<String>> getRooms() async {
    final db = await database;
    final res = await db.query('rooms', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveRooms(List<String> rooms) async {
    try {
      final db = await database;
      await db.transaction((txn) async {
        await txn.delete('rooms');
        for (var r in rooms) {
          await txn.insert('rooms', {'name': r}, conflictAlgorithm: ConflictAlgorithm.replace);
        }
      });
      logger.log("DB: Saved ${rooms.length} rooms.");
    } catch (e) {
      logger.log("DB ERROR: SaveRooms failed", error: e);
    }
  }

  Future<List<String>> getCategories() async {
    final db = await database;
    final res = await db.query('categories', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveCategories(List<String> categories) async {
    try {
      final db = await database;
      await db.transaction((txn) async {
        await txn.delete('categories');
        for (var c in categories) {
          await txn.insert('categories', {'name': c}, conflictAlgorithm: ConflictAlgorithm.replace);
        }
      });
      logger.log("DB: Saved ${categories.length} categories.");
    } catch (e) {
      logger.log("DB ERROR: SaveCategories failed", error: e);
    }
  }
}

============================================================
PATH: .\lib\models\item.dart
============================================================

import 'dart:convert';

class Item {
  final int? id;
  final String name;
  final List<String> imagePaths;
  final double value;
  final DateTime purchaseDate;
  final DateTime? warrantyExpiry;
  final String? serialNumber;
  final String? brand;
  final String? model;
  final String? notes;
  final String? room;
  final String? category;
  final List<int> receiptIndices; // Indices of images that are receipts

  Item({
    this.id,
    required this.name,
    required this.imagePaths,
    required this.value,
    required this.purchaseDate,
    this.warrantyExpiry,
    this.serialNumber,
    this.brand,
    this.model,
    this.notes,
    this.room,
    this.category,
    this.receiptIndices = const []
  });

  /// Creates a copy of this Item but with the given fields replaced with new values.
  /// This is essential for updating immutable (final) data in Flutter.
  Item copyWith({
    int? id,
    String? name,
    List<String>? imagePaths,
    double? value,
    DateTime? purchaseDate,
    DateTime? warrantyExpiry,
    String? serialNumber,
    String? brand,
    String? model,
    String? notes,
    String? room,
    String? category,
    List<int>? receiptIndices,
  }) {
    return Item(
      id: id ?? this.id,
      name: name ?? this.name,
      imagePaths: imagePaths ?? this.imagePaths,
      value: value ?? this.value,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      warrantyExpiry: warrantyExpiry ?? this.warrantyExpiry,
      serialNumber: serialNumber ?? this.serialNumber,
      brand: brand ?? this.brand,
      model: model ?? this.model,
      notes: notes ?? this.notes,
      room: room ?? this.room,
      category: category ?? this.category,
      receiptIndices: receiptIndices ?? this.receiptIndices,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'imagePaths': jsonEncode(imagePaths),
      'value': value,
      'purchaseDate': purchaseDate.toIso8601String(),
      'warrantyExpiry': warrantyExpiry?.toIso8601String(),
      'serialNumber': serialNumber,
      'brand': brand,
      'model': model,
      'notes': notes,
      'room': room,
      'category': category,
      'receiptIndices': jsonEncode(receiptIndices),
    };
  }

  factory Item.fromMap(Map<String, dynamic> map) {
    return Item(
      id: map['id'],
      name: map['name'],
      imagePaths: List<String>.from(jsonDecode(map['imagePaths'])),
      value: (map['value'] as num).toDouble(),
      purchaseDate: DateTime.parse(map['purchaseDate']),
      warrantyExpiry: map['warrantyExpiry'] != null
          ? DateTime.parse(map['warrantyExpiry'])
          : null,
      serialNumber: map['serialNumber'],
      brand: map['brand'],
      model: map['model'],
      notes: map['notes'],
      room: map['room'],
      category: map['category'],
      receiptIndices: map['receiptIndices'] != null
          ? List<int>.from(jsonDecode(map['receiptIndices']))
          : [],
    );
  }
}

============================================================
PATH: .\lib\providers\inventory_provider.dart
============================================================

import 'package:flutter/material.dart';
import '../models/item.dart';
import '../data/database_helper.dart';

enum SortOption { name, value, date }

class InventoryProvider with ChangeNotifier {
  List<Item> _items = [];
  List<String> _rooms = [];
  List<String> _categories = [];
  bool _isLoading = false;
  String _searchQuery = '';

  List<Item> get items => _items;
  List<String> get rooms => _rooms;
  List<String> get categories => _categories;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;

  SortOption _currentSort = SortOption.name;
  SortOption get currentSort => _currentSort;

  // --- INITIALIZATION ---

  Future<void> initializeData() async {
    _isLoading = true;
    notifyListeners();

    try {
      final results = await Future.wait([
        DatabaseHelper.instance.readAllItems(),
        DatabaseHelper.instance.getRooms(),
        DatabaseHelper.instance.getCategories(),
      ]);

      _items = results[0] as List<Item>;
      _rooms = results[1] as List<String>;
      _categories = results[2] as List<String>;
    } catch (e) {
      debugPrint('Error initializing data: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> refreshAfterImport() async {
    await initializeData();
  }

  // --- SEARCH & FILTERING ---

  void setSearchQuery(String query) {
    _searchQuery = query;
    notifyListeners();
  }

  void setSort(SortOption option) {
    _currentSort = option;
    notifyListeners();
  }

  List<Item> get filteredItems {
    // Start with a copy to avoid mutating the master list during sorting
    List<Item> list = [..._items];

    // 1. GLOBAL SEARCH FILTER
    if (_searchQuery.isNotEmpty) {
      final query = _searchQuery.toLowerCase();
      list = list.where((item) {
        return item.name.toLowerCase().contains(query) ||
            (item.brand?.toLowerCase().contains(query) ?? false) ||
            (item.model?.toLowerCase().contains(query) ?? false) ||
            (item.serialNumber?.toLowerCase().contains(query) ?? false) ||
            (item.room?.toLowerCase().contains(query) ?? false) ||
            (item.category?.toLowerCase().contains(query) ?? false) ||
            (item.notes?.toLowerCase().contains(query) ?? false);
      }).toList();
    }

    // 2. SORTING LOGIC
    switch (_currentSort) {
      case SortOption.name:
        list.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));
        break;
      case SortOption.value:
        list.sort((a, b) => b.value.compareTo(a.value)); // High to Low
        break;
      case SortOption.date:
      // Sort by purchase date (Newest first)
        list.sort((a, b) => b.purchaseDate.compareTo(a.purchaseDate));
        break;
    }
    return list;
  }

  // --- ACTIONS ---

  Future<void> addItem(Item item) async {
    final newItem = await DatabaseHelper.instance.create(item);
    _items.add(newItem);
    notifyListeners();
  }

  Future<void> updateItem(Item item) async {
    await DatabaseHelper.instance.update(item);
    final index = _items.indexWhere((element) => element.id == item.id);
    if (index != -1) {
      _items[index] = item;
      notifyListeners();
    }
  }

  Future<void> deleteItem(int id) async {
    await DatabaseHelper.instance.delete(id);
    _items.removeWhere((item) => item.id == id);
    notifyListeners();
  }

  // --- ROOMS & CATEGORIES ---

  Future<void> addRoom(String name) async {
    final trimmedName = name.trim();
    if (trimmedName.isNotEmpty && !_rooms.contains(trimmedName)) {
      _rooms.add(trimmedName);
      _rooms.sort();
      await DatabaseHelper.instance.saveRooms(_rooms);
      notifyListeners();
    }
  }

  Future<void> removeRoom(String name) async {
    _rooms.remove(name);
    await DatabaseHelper.instance.saveRooms(_rooms);
    notifyListeners();
  }

  Future<void> addCategory(String name) async {
    final trimmedName = name.trim();
    if (trimmedName.isNotEmpty && !_categories.contains(trimmedName)) {
      _categories.add(trimmedName);
      _categories.sort();
      await DatabaseHelper.instance.saveCategories(_categories);
      notifyListeners();
    }
  }

  Future<void> removeCategory(String name) async {
    _categories.remove(name);
    await DatabaseHelper.instance.saveCategories(_categories);
    notifyListeners();
  }

  Future<void> clearAll() async {
    await DatabaseHelper.instance.deleteAllItems();
    _items.clear();
    notifyListeners();
  }

  // --- HELPER COUNTS ---

  int getItemsCountInRoom(String roomName) => _items.where((i) => i.room == roomName).length;
  int getItemsCountInCategory(String catName) => _items.where((i) => i.category == catName).length;
  double get totalValue => _items.fold(0.0, (sum, item) => sum + item.value);
}

============================================================
PATH: .\lib\providers\settings_provider.dart
============================================================

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SettingsProvider with ChangeNotifier {
  String _userName = "";
  String _address = "";
  String _policyNumber = "";
  ThemeMode _themeMode = ThemeMode.system;

  String get userName => _userName;
  String get address => _address;
  String get policyNumber => _policyNumber;
  ThemeMode get themeMode => _themeMode;
  String _insuranceCompany = "";
  String get insuranceCompany => _insuranceCompany;

  SettingsProvider() {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    _userName = prefs.getString('userName') ?? "";
    _address = prefs.getString('address') ?? "";
    _policyNumber = prefs.getString('policyNumber') ?? "";
    _themeMode = ThemeMode.values[prefs.getInt('themeMode') ?? 0];
    _insuranceCompany = prefs.getString('insuranceCompany') ?? "";
    notifyListeners();
  }

  Future<void> updateProfile(String name, String addr, String policy, String company) async {
    final prefs = await SharedPreferences.getInstance();
    _userName = name;
    _address = addr;
    _policyNumber = policy;
    _insuranceCompany = company;
    await prefs.setString('userName', name);
    await prefs.setString('address', addr);
    await prefs.setString('policyNumber', policy);
    await prefs.setString('insuranceCompany', company);
    notifyListeners();
  }

  Future<void> setThemeMode(ThemeMode mode) async {
    final prefs = await SharedPreferences.getInstance();
    _themeMode = mode;
    await prefs.setInt('themeMode', mode.index);
    notifyListeners();
  }
}

============================================================
PATH: .\lib\repositories\list_repository.dart
============================================================

import '../data/database_helper.dart';

class ListRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;

  // Rooms logic
  Future<List<String>> fetchRooms() async {
    final rooms = await _db.getRooms();
    // Professional touch: If DB is empty, provide defaults but don't save them yet
    if (rooms.isEmpty) {
      return ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
    }
    return rooms;
  }

  Future<void> updateRooms(List<String> rooms) => _db.saveRooms(rooms);

  // Categories logic
  Future<List<String>> fetchCategories() async {
    final categories = await _db.getCategories();
    if (categories.isEmpty) {
      return ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];
    }
    return categories;
  }

  Future<void> updateCategories(List<String> categories) => _db.saveCategories(categories);
}

============================================================
PATH: .\lib\screens\add_item_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import '../widgets/barcode_scanner.dart';

class AddItemScreen extends StatefulWidget {
  final Item? itemToEdit;
  const AddItemScreen({super.key, this.itemToEdit});

  @override
  State<AddItemScreen> createState() => _AddItemScreenState();
}

class _AddItemScreenState extends State<AddItemScreen> {
  final _formKey = GlobalKey<FormState>();

  // Controllers
  final _nameController = TextEditingController();
  final _valueController = TextEditingController();
  final _serialController = TextEditingController();
  final _brandController = TextEditingController();
  final _modelController = TextEditingController();
  final _notesController = TextEditingController();

  // State Variables
  List<File> _imageFiles = [];
  List<int> _receiptIndices = [];
  String? _selectedRoom;
  String? _selectedCategory;
  DateTime _purchaseDate = DateTime.now();
  DateTime? _warrantyExpiry;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    if (widget.itemToEdit != null) {
      final item = widget.itemToEdit!;
      _nameController.text = item.name;
      _valueController.text = item.value == 0.0 ? '' : item.value.toString();
      _serialController.text = item.serialNumber ?? '';
      _brandController.text = item.brand ?? '';
      _modelController.text = item.model ?? '';
      _notesController.text = item.notes ?? '';
      _selectedRoom = item.room;
      _selectedCategory = item.category;
      _purchaseDate = item.purchaseDate;
      _warrantyExpiry = item.warrantyExpiry;
      _receiptIndices = List.from(item.receiptIndices);
      _imageFiles = item.imagePaths.map((path) => File(path)).toList();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _valueController.dispose();
    _serialController.dispose();
    _brandController.dispose();
    _modelController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  // --- LOGIC ---

  Future<void> _pickImage(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: source, imageQuality: 75);
    if (pickedFile != null) {
      setState(() => _imageFiles.add(File(pickedFile.path)));
    }
  }

  Future<void> _selectDate(BuildContext context, bool isPurchaseDate) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: isPurchaseDate ? _purchaseDate : (_warrantyExpiry ?? DateTime.now().add(const Duration(days: 365))),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) {
      setState(() {
        if (isPurchaseDate) _purchaseDate = picked;
        else _warrantyExpiry = picked;
      });
    }
  }

  Future<void> _saveItem() async {
    if (_isSaving || !_formKey.currentState!.validate()) return;
    if (_imageFiles.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('At least one photo is required.')));
      return;
    }

    setState(() => _isSaving = true);
    try {
      final appDir = await getApplicationDocumentsDirectory();
      List<String> savedPaths = [];

      for (var file in _imageFiles) {
        // If image is already in app dir (editing existing), keep it
        if (file.path.contains(appDir.path)) {
          savedPaths.add(file.path);
        } else {
          // Compress and save new images
          final fileName = 'img_${DateTime.now().millisecondsSinceEpoch}_${path.basename(file.path)}';
          final targetPath = '${appDir.path}/$fileName';
          var result = await FlutterImageCompress.compressAndGetFile(
            file.absolute.path,
            targetPath,
            quality: 70,
            minWidth: 1024,
            minHeight: 1024,
          );
          savedPaths.add(result?.path ?? (await file.copy(targetPath)).path);
        }
      }

      final newItem = Item(
        id: widget.itemToEdit?.id,
        name: _nameController.text.trim(),
        imagePaths: savedPaths,
        value: double.tryParse(_valueController.text.replaceAll(',', '')) ?? 0.0,
        purchaseDate: _purchaseDate,
        warrantyExpiry: _warrantyExpiry,
        serialNumber: _serialController.text.isEmpty ? null : _serialController.text,
        brand: _brandController.text.isEmpty ? null : _brandController.text,
        model: _modelController.text.isEmpty ? null : _modelController.text,
        notes: _notesController.text.isEmpty ? null : _notesController.text,
        room: (_selectedRoom == "None" || _selectedRoom == null) ? null : _selectedRoom,
        category: (_selectedCategory == "None" || _selectedCategory == null) ? null : _selectedCategory,
        receiptIndices: _receiptIndices,
      );

      final provider = Provider.of<InventoryProvider>(context, listen: false);
      if (widget.itemToEdit == null) {
        await provider.addItem(newItem);
      } else {
        await provider.updateItem(newItem);
      }

      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  // --- UI ---

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final provider = context.watch<InventoryProvider>();
    final roomOptions = ["None", ...provider.rooms];
    final categoryOptions = ["None", ...provider.categories];

    return Scaffold(
      appBar: AppBar(title: Text(widget.itemToEdit == null ? 'Add Full Item' : 'Edit Item')),
      body: _isSaving
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildPhotoHeader(),
              _buildPhotoGallery(theme),
              const SizedBox(height: 24),

              _buildTextField(_nameController, 'Item Name', Icons.inventory_2, isRequired: true),
              _buildTextField(_valueController, 'Estimated Value (\$)', Icons.monetization_on, isNumber: true),

              Row(
                children: [
                  Expanded(child: _buildDatePicker('Purchase Date', _purchaseDate, () => _selectDate(context, true))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDatePicker('Warranty Until', _warrantyExpiry, () => _selectDate(context, false), isOptional: true)),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildDropdown('Room', _selectedRoom, roomOptions, (val) => setState(() => _selectedRoom = val))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDropdown('Category', _selectedCategory, categoryOptions, (val) => setState(() => _selectedCategory = val))),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildTextField(_brandController, 'Brand', Icons.factory)),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_modelController, 'Model #', Icons.label_important)),
                ],
              ),

              _buildScanTextField(_serialController, 'Serial Number / UPC', Icons.qr_code_scanner),
              _buildTextField(_notesController, 'Notes / Description', Icons.description, maxLines: 3),

              const SizedBox(height: 32),
              _buildSaveButton(theme),
              const SizedBox(height: 50),
            ],
          ),
        ),
      ),
    );
  }

  // --- COMPONENTS ---

  Widget _buildPhotoHeader() {
    return const Padding(
      padding: EdgeInsets.only(bottom: 8),
      child: Text("Photos & Receipts *", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
    );
  }

  Widget _buildPhotoGallery(ThemeData theme) {
    return SizedBox(
      height: 140,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: _imageFiles.length + 1,
        itemBuilder: (ctx, i) {
          if (i == _imageFiles.length) return _buildAddPhotoButton(theme);
          bool isReceipt = _receiptIndices.contains(i);
          return _buildPhotoPreview(i, isReceipt);
        },
      ),
    );
  }

  Widget _buildPhotoPreview(int index, bool isReceipt) {
    return Stack(
      children: [
        Container(
          margin: const EdgeInsets.only(right: 12, top: 10),
          width: 110,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            image: DecorationImage(image: FileImage(_imageFiles[index]), fit: BoxFit.cover),
            border: Border.all(color: isReceipt ? Colors.green : Colors.transparent, width: 3),
          ),
        ),
        Positioned(
          right: 0, top: 0,
          child: GestureDetector(
            onTap: () => setState(() {
              _imageFiles.removeAt(index);
              _receiptIndices.remove(index);
              _receiptIndices = _receiptIndices.map((e) => e > index ? e - 1 : e).toList();
            }),
            child: const CircleAvatar(radius: 12, backgroundColor: Colors.red, child: Icon(Icons.close, size: 16, color: Colors.white)),
          ),
        ),
        Positioned(
          left: 5, bottom: 5,
          child: GestureDetector(
            onTap: () => setState(() => _receiptIndices.contains(index) ? _receiptIndices.remove(index) : _receiptIndices.add(index)),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(color: isReceipt ? Colors.green : Colors.black54, borderRadius: BorderRadius.circular(8)),
              child: Row(children: [
                const Icon(Icons.receipt_long, size: 12, color: Colors.white),
                const SizedBox(width: 4),
                Text(isReceipt ? "Receipt" : "Tag Receipt", style: const TextStyle(color: Colors.white, fontSize: 10)),
              ]),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTextField(TextEditingController controller, String label, IconData icon, {bool isNumber = false, int maxLines = 1, bool isRequired = false}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        maxLines: maxLines,
        keyboardType: isNumber ? const TextInputType.numberWithOptions(decimal: true) : TextInputType.text,
        decoration: InputDecoration(
          labelText: isRequired ? label : '$label (Optional)',
          prefixIcon: Icon(icon),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
        ),
        validator: (v) => (isRequired && (v == null || v.trim().isEmpty)) ? 'Please enter $label' : null,
      ),
    );
  }

  Widget _buildScanTextField(TextEditingController controller, String label, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: '$label (Optional)',
          prefixIcon: Icon(icon),
          suffixIcon: IconButton(
            icon: Icon(Icons.camera_alt, color: Theme.of(context).colorScheme.primary),
            onPressed: () async {
              final String? scannedCode = await Navigator.push(
                  context,
                  MaterialPageRoute(builder: (context) => const BarcodeScannerWidget())
              );
              if (scannedCode != null && mounted) setState(() => controller.text = scannedCode);
            },
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
        ),
      ),
    );
  }

  Widget _buildDatePicker(String label, DateTime? date, VoidCallback onTap, {bool isOptional = false}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: onTap,
        child: InputDecorator(
          decoration: InputDecoration(
            labelText: isOptional ? '$label (Optional)' : label,
            border: const OutlineInputBorder(),
          ),
          child: Text(date == null ? 'Select Date' : DateFormat('MMM d, yyyy').format(date)),
        ),
      ),
    );
  }

  Widget _buildDropdown(String label, String? value, List<String> items, Function(String?) onChanged) {
    final effectiveValue = items.contains(value) ? value : "None";
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: DropdownButtonFormField<String>(
        value: effectiveValue,
        decoration: InputDecoration(labelText: '$label (Optional)', border: OutlineInputBorder(borderRadius: BorderRadius.circular(8))),
        items: items.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildAddPhotoButton(ThemeData theme) {
    return GestureDetector(
      onTap: () => _showPickerOptions(),
      child: Container(
        margin: const EdgeInsets.only(top: 10),
        width: 100,
        decoration: BoxDecoration(
            color: theme.colorScheme.surfaceVariant,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(color: theme.colorScheme.outlineVariant)
        ),
        child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
          Icon(Icons.add_a_photo, color: theme.colorScheme.primary),
          const SizedBox(height: 4),
          Text("Add Photo", style: TextStyle(fontSize: 12, color: theme.colorScheme.primary)),
        ]),
      ),
    );
  }

  void _showPickerOptions() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) => Padding(
        padding: const EdgeInsets.symmetric(vertical: 20),
        child: Column(mainAxisSize: MainAxisSize.min, children: [
          ListTile(leading: const Icon(Icons.camera_alt), title: const Text('Take Photo'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.camera); }),
          ListTile(leading: const Icon(Icons.photo_library), title: const Text('From Gallery'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.gallery); }),
        ]),
      ),
    );
  }

  Widget _buildSaveButton(ThemeData theme) {
    return ElevatedButton.icon(
      onPressed: _saveItem,
      icon: const Icon(Icons.check_circle),
      label: const Text('SAVE TO INVENTORY', style: TextStyle(fontWeight: FontWeight.bold)),
      style: ElevatedButton.styleFrom(
        minimumSize: const Size(double.infinity, 60),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\dev_logs_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../services/logger_service.dart';

class DevLogsScreen extends StatefulWidget {
  const DevLogsScreen({super.key});

  @override
  State<DevLogsScreen> createState() => _DevLogsScreenState();
}

class _DevLogsScreenState extends State<DevLogsScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("System Logs"),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              Clipboard.setData(ClipboardData(text: logger.logs.join('\n')));
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Logs copied")));
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete_sweep),
            onPressed: () => setState(() => logger.clear()),
          ),
        ],
      ),
      body: ListView.separated(
        padding: const EdgeInsets.all(16),
        itemCount: logger.logs.length,
        separatorBuilder: (_, __) => const Divider(),
        itemBuilder: (context, index) {
          final log = logger.logs[index];
          final isError = log.toLowerCase().contains('error') || log.toLowerCase().contains('exception');
          return Text(
            log,
            style: TextStyle(
              fontFamily: 'monospace',
              fontSize: 12,
              color: isError ? Colors.red : Colors.grey[800],
            ),
          );
        },
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\fast_add_screen.dart
============================================================

import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:speech_to_text/speech_to_text.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';

class FastAddScreen extends StatefulWidget {
  const FastAddScreen({super.key});

  @override
  State<FastAddScreen> createState() => _FastAddScreenState();
}

class _FastAddScreenState extends State<FastAddScreen> {
  CameraController? _controller;
  final SpeechToText _speech = SpeechToText();
  final TextEditingController _textController = TextEditingController();
  final List<Item> _sessionItems = []; // Track items added in this specific session

  bool _isProcessing = false;
  bool _isListening = false;
  bool _voiceMode = false; // Defaults to Keyboard
  String? _sessionRoom;
  String? _sessionCategory;

  @override
  void initState() {
    super.initState();
    _initCamera();
    _speech.initialize();
  }

  Future<void> _initCamera() async {
    final cameras = await availableCameras();
    if (cameras.isNotEmpty) {
      _controller = CameraController(cameras[0], ResolutionPreset.high, enableAudio: false);
      await _controller!.initialize();
      if (mounted) setState(() {});
    }
  }

  // --- CAPTURE & SESSION LOGIC ---

  void _startListeningCapture() async {
    if (_isListening) return;

    setState(() => _isListening = true);
    await _speech.listen(
      onResult: (result) {
        if (result.finalResult) {
          setState(() => _isListening = false);
          _handleCapture(nameOverride: result.recognizedWords);
        }
      },
    );
  }

  Future<void> _handleCapture({String? nameOverride}) async {
    if (_isProcessing || _controller == null || !_controller!.value.isInitialized) return;

    setState(() => _isProcessing = true);
    try {
      final photo = await _controller!.takePicture();

      String name = nameOverride ?? _textController.text.trim();
      if (name.isEmpty) {
        name = "Item ${DateFormat('jm').format(DateTime.now())}";
      }

      final savedItem = await _saveItem(photo.path, name);

      setState(() {
        _sessionItems.insert(0, savedItem); // Add to local session list
        _isProcessing = false;
        _textController.clear();
      });
    } catch (e) {
      setState(() => _isProcessing = false);
      debugPrint("Capture Error: $e");
    }
  }

  Future<Item> _saveItem(String path, String name) async {
    final appDir = await getApplicationDocumentsDirectory();
    final fileName = 'fast_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final savedFile = await File(path).copy('${appDir.path}/$fileName');

    final newItem = Item(
      name: name,
      imagePaths: [savedFile.path],
      value: 0.0,
      purchaseDate: DateTime.now(),
      room: _sessionRoom,
      category: _sessionCategory,
    );

    await Provider.of<InventoryProvider>(context, listen: false).addItem(newItem);
    return newItem;
  }

  void _showReviewModal() {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.grey[900],
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (context) => StatefulBuilder( // Use StatefulBuilder to update UI within modal
        builder: (context, setModalState) => DraggableScrollableSheet(
          initialChildSize: 0.7,
          maxChildSize: 0.95,
          expand: false,
          builder: (_, scrollController) => Column(
            children: [
              Container(
                margin: const EdgeInsets.symmetric(vertical: 12),
                width: 40, height: 4,
                decoration: BoxDecoration(color: Colors.white24, borderRadius: BorderRadius.circular(2)),
              ),

              // --- HEADER WITH BATCH EDIT ---
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    const Text("SESSION REVIEW", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    if (_sessionItems.isNotEmpty)
                      TextButton.icon(
                        onPressed: () => _handleBatchEdit(context, setModalState),
                        icon: const Icon(Icons.edit_note, size: 18, color: Colors.blue),
                        label: const Text("BATCH EDIT", style: TextStyle(color: Colors.blue, fontSize: 12)),
                      ),
                  ],
                ),
              ),

              const Divider(color: Colors.white10),

              Expanded(
                child: _sessionItems.isEmpty
                    ? const Center(child: Text("No items recorded.", style: TextStyle(color: Colors.white54)))
                    : GridView.builder(
                  controller: scrollController,
                  padding: const EdgeInsets.all(16),
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 3, crossAxisSpacing: 10, mainAxisSpacing: 10, childAspectRatio: 0.8,
                  ),
                  itemCount: _sessionItems.length,
                  itemBuilder: (ctx, i) => _buildGridItem(_sessionItems[i]),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

// --- BATCH EDIT LOGIC ---

  Future<void> _handleBatchEdit(BuildContext context, StateSetter setModalState) async {
    final provider = Provider.of<InventoryProvider>(context, listen: false);

    String? selectedRoom = _sessionRoom;

    await showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: Colors.grey[900],
        title: const Text("Batch Update Room", style: TextStyle(color: Colors.white, fontSize: 16)),
        content: DropdownButtonFormField<String>(
          value: selectedRoom,
          dropdownColor: Colors.grey[850],
          style: const TextStyle(color: Colors.white),
          items: provider.rooms.map((r) => DropdownMenuItem(value: r, child: Text(r))).toList(),
          onChanged: (val) => selectedRoom = val,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
          ElevatedButton(
            onPressed: () async {
              final provider = Provider.of<InventoryProvider>(context, listen: false);

              // We need to update both the Provider AND our local session list
              for (int i = 0; i < _sessionItems.length; i++) {
                // 1. Create the updated version of the item
                final updatedItem = _sessionItems[i].copyWith(room: selectedRoom);

                // 2. Update it in the database/provider
                await provider.updateItem(updatedItem);

                // 3. Update our local list so the Review Grid reflects the change
                _sessionItems[i] = updatedItem;
              }

              setModalState(() {}); // Refresh the grid view
              Navigator.pop(ctx);

              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text("Updated ${_sessionItems.length} items to $selectedRoom")),
              );
            },
            child: const Text("APPLY TO ALL"),
          ),
        ],
      ),
    );
  }

  Widget _buildGridItem(Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          child: ClipRRect(
            borderRadius: BorderRadius.circular(12),
            child: Stack(
              fit: StackFit.expand,
              children: [
                Image.file(File(item.imagePaths[0]), fit: BoxFit.cover),
                Positioned(
                  bottom: 0, left: 0, right: 0,
                  child: Container(
                    padding: const EdgeInsets.symmetric(vertical: 2, horizontal: 4),
                    color: Colors.black54,
                    child: Text(item.room ?? "No Room", style: const TextStyle(color: Colors.white70, fontSize: 8), overflow: TextOverflow.ellipsis),
                  ),
                )
              ],
            ),
          ),
        ),
        const SizedBox(height: 4),
        Text(item.name, maxLines: 1, style: const TextStyle(color: Colors.white, fontSize: 11)),
      ],
    );
  }

  // --- BUILD UI ---

  @override
  Widget build(BuildContext context) {
    if (_controller == null || !_controller!.value.isInitialized) {
      return const Scaffold(backgroundColor: Colors.black, body: Center(child: CircularProgressIndicator()));
    }

    final provider = context.watch<InventoryProvider>();
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return Scaffold(
      backgroundColor: Colors.black,
      resizeToAvoidBottomInset: false,
      body: Stack(
        children: [
          Positioned.fill(child: CameraPreview(_controller!)),

          // Header Bar
          Positioned(top: 60, left: 16, right: 16, child: _buildSessionBar(provider)),

          // Mode Switcher
          Positioned(
            top: 130, right: 16,
            child: FloatingActionButton.small(
              heroTag: "modeToggle",
              backgroundColor: _voiceMode ? Colors.blue : Colors.black45,
              onPressed: () => setState(() => _voiceMode = !_voiceMode),
              child: Icon(_voiceMode ? Icons.mic : Icons.keyboard, color: Colors.white),
            ),
          ),

          // Main Bottom UI
          Positioned(
            bottom: bottomInset > 0 ? bottomInset + 20 : 50,
            left: 0, right: 0,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _voiceMode ? _buildVoiceIndicator() : _buildTextInput(),
                const SizedBox(height: 30),
                _buildActionRow(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSessionBar(InventoryProvider provider) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.black54,
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: Colors.white10),
      ),
      child: Row(
        children: [
          IconButton(icon: const Icon(Icons.close, color: Colors.white), onPressed: () => Navigator.pop(context)),
          Expanded(child: _buildCompactDropdown("Room", _sessionRoom, provider.rooms, (val) => setState(() => _sessionRoom = val))),
          const SizedBox(width: 8),
          Expanded(child: _buildCompactDropdown("Category", _sessionCategory, provider.categories, (val) => setState(() => _sessionCategory = val))),
        ],
      ),
    );
  }

  Widget _buildTextInput() {
    return Container(
      width: 280,
      child: TextField(
        controller: _textController,
        textAlign: TextAlign.center,
        style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
        decoration: InputDecoration(
          hintText: "Item Name (Optional)",
          hintStyle: const TextStyle(color: Colors.white38, fontSize: 14),
          filled: true,
          fillColor: Colors.black54,
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(30), borderSide: BorderSide.none),
        ),
      ),
    );
  }

  Widget _buildVoiceIndicator() {
    return Column(
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 300),
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(
            color: _isListening ? Colors.blue : Colors.black54,
            shape: BoxShape.circle,
          ),
          child: const Icon(Icons.mic, color: Colors.white, size: 28),
        ),
        const SizedBox(height: 8),
        Text(_isListening ? "Listening..." : "Tap Shutter to Speak & Snap",
            style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.w500)),
      ],
    );
  }

  Widget _buildActionRow() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        // Review
        _buildBottomCircleBtn(
            icon: Icons.grid_view_rounded,
            label: "REVIEW",
            onTap: _showReviewModal,
            badge: _sessionItems.length
        ),

        // Shutter
        GestureDetector(
          onTap: _voiceMode ? _startListeningCapture : _handleCapture,
          child: Container(
            height: 84, width: 84,
            decoration: BoxDecoration(shape: BoxShape.circle, border: Border.all(color: Colors.white, width: 4)),
            child: Center(
              child: Container(
                height: 68, width: 68,
                decoration: const BoxDecoration(color: Colors.white, shape: BoxShape.circle),
                child: _isProcessing
                    ? const Padding(padding: EdgeInsets.all(20), child: CircularProgressIndicator(strokeWidth: 2, color: Colors.black))
                    : Icon(_voiceMode ? Icons.mic : Icons.camera_alt, color: Colors.black, size: 28),
              ),
            ),
          ),
        ),

        // Done
        _buildBottomCircleBtn(icon: Icons.check, label: "FINISH", onTap: () => Navigator.pop(context)),
      ],
    );
  }

  Widget _buildBottomCircleBtn({required IconData icon, required String label, required VoidCallback onTap, int badge = 0}) {
    return Column(
      children: [
        Stack(
          clipBehavior: Clip.none,
          children: [
            IconButton(
              onPressed: onTap,
              icon: Container(
                padding: const EdgeInsets.all(10),
                decoration: const BoxDecoration(color: Colors.black45, shape: BoxShape.circle),
                child: Icon(icon, color: Colors.white, size: 22),
              ),
            ),
            if (badge > 0)
              Positioned(
                top: 0, right: 0,
                child: Container(
                  padding: const EdgeInsets.all(5),
                  decoration: const BoxDecoration(color: Colors.blue, shape: BoxShape.circle),
                  child: Text("$badge", style: const TextStyle(color: Colors.white, fontSize: 9, fontWeight: FontWeight.bold)),
                ),
              )
          ],
        ),
        Text(label, style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)),
      ],
    );
  }

  Widget _buildCompactDropdown(String hint, String? value, List<String> items, Function(String?) onChanged) {
    return DropdownButtonHideUnderline(
      child: DropdownButton<String>(
        value: value, isExpanded: true,
        hint: Text(hint, style: const TextStyle(color: Colors.white60, fontSize: 12)),
        dropdownColor: Colors.black87,
        icon: const Icon(Icons.expand_more, color: Colors.white38, size: 16),
        style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold),
        items: items.map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
        onChanged: onChanged,
      ),
    );
  }

  @override
  void dispose() {
    _controller?.dispose();
    _speech.stop();
    _textController.dispose();
    super.dispose();
  }
}

============================================================
PATH: .\lib\screens\home_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';

import '../providers/inventory_provider.dart';
import '../providers/settings_provider.dart';
import '../services/pdf_service.dart';
import '../services/zip_service.dart';
import '../services/export_service.dart';

import '../widgets/barcode_scanner.dart';
import 'add_item_screen.dart';
import 'item_detail_screen.dart';
import 'settings_screen.dart';
import 'fast_add_screen.dart';


class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final ScrollController _scrollController = ScrollController();
  final TextEditingController _searchController = TextEditingController();

  bool _isSearching = false;
  bool _showActions = true;

  // --- SELECTION STATE ---
  final Set<int> _selectedIds = {};
  bool get _isSelectionMode => _selectedIds.isNotEmpty;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      if (_scrollController.position.userScrollDirection == ScrollDirection.reverse) {
        if (_showActions) setState(() => _showActions = false);
      } else if (_scrollController.position.userScrollDirection == ScrollDirection.forward) {
        if (!_showActions) setState(() => _showActions = true);
      }
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  // --- SELECTION HELPERS ---

  void _toggleSelection(int id) {
    setState(() {
      if (_selectedIds.contains(id)) {
        _selectedIds.remove(id);
      } else {
        _selectedIds.add(id);
      }
    });
  }

  void _clearSelection() {
    setState(() => _selectedIds.clear());
  }

  Future<void> _confirmBatchDelete() async {
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    final count = _selectedIds.length;

    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text("Delete $count items?"),
        content: const Text("This will permanently remove these items and all associated photos."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("CANCEL")),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("DELETE", style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
    );

    if (confirm == true) {
      for (var id in _selectedIds) {
        await provider.deleteItem(id);
      }
      _clearSelection();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Successfully deleted $count items")),
        );
      }
    }
  }

  // --- SMART SEARCH HIGHLIGHTER ---

  Widget _buildHighlightedText(String fullText, String query, TextStyle baseStyle) {
    if (query.isEmpty || !fullText.toLowerCase().contains(query.toLowerCase())) {
      return Text(fullText, style: baseStyle, overflow: TextOverflow.ellipsis);
    }

    final String searchLower = query.toLowerCase();
    final String textLower = fullText.toLowerCase();
    final List<TextSpan> spans = [];

    int start = 0;
    int indexOfMatch;

    while ((indexOfMatch = textLower.indexOf(searchLower, start)) != -1) {
      if (indexOfMatch > start) {
        spans.add(TextSpan(text: fullText.substring(start, indexOfMatch)));
      }

      spans.add(TextSpan(
        text: fullText.substring(indexOfMatch, indexOfMatch + query.length),
        style: TextStyle(
          backgroundColor: Colors.yellow.withOpacity(0.5),
          color: Colors.black,
          fontWeight: FontWeight.bold,
        ),
      ));

      start = indexOfMatch + query.length;
    }

    if (start < fullText.length) {
      spans.add(TextSpan(text: fullText.substring(start)));
    }

    return RichText(
      overflow: TextOverflow.ellipsis,
      text: TextSpan(style: baseStyle, children: spans),
    );
  }

  // --- UI COMPONENTS ---

  void _showExportMenu(BuildContext context) {
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    final settings = Provider.of<SettingsProvider>(context, listen: false);

    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text("Export Inventory", style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 15),
              _buildExportTile(ctx, "Insurance PDF Report", Icons.picture_as_pdf, const Color(0xFFB71C1C),
                      () => PdfService.generateInventoryReport(provider.items, settings)),
              _buildExportTile(ctx, "CSV Spreadsheet", Icons.table_chart, const Color(0xFF2E7D32),
                      () => ExportService.shareAsCsv(provider.items)),
              _buildExportTile(ctx, "Full ZIP Backup", Icons.folder_zip, const Color(0xFF455A64), () {
                final allImages = provider.items.expand((item) => item.imagePaths).toList();
                ZipService.createFullBackup(allImages);
              }),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildExportTile(BuildContext context, String title, IconData icon, Color color, VoidCallback onTap) {
    return ListTile(
      leading: CircleAvatar(backgroundColor: color, child: Icon(icon, color: Colors.white, size: 20)),
      title: Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
      onTap: () {
        Navigator.pop(context);
        onTap();
      },
    );
  }

  PreferredSizeWidget _buildAppBar(InventoryProvider provider, ThemeData theme) {
    if (_isSelectionMode) {
      return AppBar(
        backgroundColor: theme.colorScheme.secondaryContainer,
        leading: IconButton(
          icon: const Icon(Icons.close),
          onPressed: _clearSelection,
        ),
        title: Text("${_selectedIds.length} Selected",
            style: TextStyle(color: theme.colorScheme.onSecondaryContainer, fontWeight: FontWeight.bold)),
        actions: [
          IconButton(
            icon: const Icon(Icons.delete_outline),
            onPressed: _confirmBatchDelete,
          ),
        ],
      );
    }

    return AppBar(
      elevation: 0,
      // Wrap the Title content to prevent the "99999 pixel" overflow
      title: _isSearching
          ? Container(
        height: 40,
        decoration: BoxDecoration(
          color: theme.colorScheme.surfaceVariant.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8),
        ),
        child: TextField(
          controller: _searchController,
          autofocus: true,
          style: const TextStyle(fontSize: 16),
          decoration: const InputDecoration(
            hintText: 'Search...',
            border: InputBorder.none,
            prefixIcon: Icon(Icons.search, size: 20),
            contentPadding: EdgeInsets.symmetric(vertical: 10),
          ),
          onChanged: (val) => provider.setSearchQuery(val),
        ),
      )
          : const Text('My Inventory', style: TextStyle(fontWeight: FontWeight.bold)),
      actions: [
        // 1. Search Toggle Button (Shows 'Close' when searching)
        IconButton(
          icon: Icon(_isSearching ? Icons.close : Icons.search),
          onPressed: () {
            setState(() {
              _isSearching = !_isSearching;
              if (!_isSearching) {
                _searchController.clear();
                provider.setSearchQuery('');
              }
            });
          },
        ),

        // Only show these icons if NOT currently searching to save space
        if (!_isSearching) ...[
          IconButton(
            icon: const Icon(Icons.qr_code_scanner_rounded),
            tooltip: 'Scan Barcode',
            onPressed: () async {
              final String? code = await Navigator.of(context).push(
                MaterialPageRoute(builder: (_) => const BarcodeScannerWidget()),
              );
              if (code != null && mounted) {
                setState(() {
                  _isSearching = true;
                  _searchController.text = code;
                });
                provider.setSearchQuery(code);
              }
            },
          ),
          PopupMenuButton<SortOption>(
            icon: const Icon(Icons.sort_rounded),
            onSelected: (option) => provider.setSort(option),
            itemBuilder: (context) => [
              const PopupMenuItem(value: SortOption.name, child: Text("Sort by Name")),
              const PopupMenuItem(value: SortOption.value, child: Text("Sort by Value")),
              const PopupMenuItem(value: SortOption.date, child: Text("Sort by Date")),
            ],
          ),
          IconButton(
            icon: const Icon(Icons.ios_share),
            onPressed: () => _showExportMenu(context),
          ),
          IconButton(
            icon: const Icon(Icons.settings_outlined),
            onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (context) => const SettingsScreen())),
          ),
        ],
      ],
    );
  }

  @override
  Widget build(BuildContext context) {
    final provider = context.watch<InventoryProvider>();
    final theme = Theme.of(context);

    return Scaffold(
      appBar: _buildAppBar(provider, theme),
      body: Stack(
        children: [
          Column(
            children: [
              if (!_isSearching && provider.items.isNotEmpty && !_isSelectionMode)
                _buildTotalValueBanner(theme, provider.totalValue),
              Expanded(
                child: provider.isLoading
                    ? const Center(child: CircularProgressIndicator())
                    : _buildItemList(provider, theme),
              ),
            ],
          ),
          if (!_isSelectionMode) _buildActionDock(theme),
        ],
      ),
    );
  }

  Widget _buildTotalValueBanner(ThemeData theme, double total) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 20),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor, width: 0.5)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text("ESTIMATED TOTAL ASSETS",
              style: TextStyle(fontSize: 11, fontWeight: FontWeight.w600, color: Colors.grey[600], letterSpacing: 0.5)),
          Text(
            NumberFormat.simpleCurrency().format(total),
            style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.primary, fontSize: 16),
          ),
        ],
      ),
    );
  }

  Widget _buildItemList(InventoryProvider provider, ThemeData theme) {
    final displayItems = provider.filteredItems;
    final query = provider.searchQuery.toLowerCase();

    if (displayItems.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.inventory_2_outlined, size: 64, color: Colors.grey[300]),
            const SizedBox(height: 16),
            Text(_isSearching ? 'No matches found.' : 'Inventory is empty.', style: const TextStyle(color: Colors.grey)),
          ],
        ),
      );
    }

    return ListView.builder(
      controller: _scrollController,
      itemCount: displayItems.length + 1, // +1 for the sort label
      padding: EdgeInsets.fromLTRB(0, 8, 0, _isSelectionMode ? 20 : 120),
      itemBuilder: (context, index) {
        // --- 1. SORT LABEL (First Item) ---
        if (index == 0) {
          String sortText = "Sorted by Name";
          if (provider.currentSort == SortOption.value) sortText = "Sorted by Highest Value";
          if (provider.currentSort == SortOption.date) sortText = "Sorted by Newest First";

          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
            child: Text(sortText.toUpperCase(),
                style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: Colors.grey[500], letterSpacing: 1.0)),
          );
        }

        final item = displayItems[index - 1];
        final bool incomplete = item.value == 0 || item.room == null;
        final isSelected = _selectedIds.contains(item.id);

        String subtitleText = "${item.room ?? 'Unassigned'}  ${item.category ?? 'General'}";

        if (query.isNotEmpty) {
          if (item.brand?.toLowerCase().contains(query) ?? false) {
            subtitleText = "Brand: ${item.brand}  $subtitleText";
          } else if (item.model?.toLowerCase().contains(query) ?? false) {
            subtitleText = "Model: ${item.model}  $subtitleText";
          } else if (item.serialNumber?.toLowerCase().contains(query) ?? false) {
            subtitleText = "S/N: ${item.serialNumber}  $subtitleText";
          }
        }

        return Column(
          children: [
            AnimatedContainer(
              duration: const Duration(milliseconds: 200),
              color: isSelected ? theme.colorScheme.primaryContainer.withOpacity(0.3) : Colors.transparent,
              child: ListTile(
                contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 4),
                onLongPress: () => _toggleSelection(item.id!),
                onTap: () {
                  if (_isSelectionMode) {
                    _toggleSelection(item.id!);
                  } else {
                    Navigator.of(context).push(MaterialPageRoute(builder: (context) => ItemDetailScreen(itemId: item.id!)));
                  }
                },
                leading: Stack(
                  children: [
                    Container(
                      width: 54, height: 54,
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(12),
                        color: theme.colorScheme.surfaceVariant,
                        image: item.imagePaths.isNotEmpty
                            ? DecorationImage(image: FileImage(File(item.imagePaths[0])), fit: BoxFit.cover)
                            : null,
                      ),
                      child: item.imagePaths.isEmpty ? const Icon(Icons.image_outlined, color: Colors.grey) : null,
                    ),
                    if (isSelected)
                      Positioned.fill(
                        child: Container(
                          decoration: BoxDecoration(
                            borderRadius: BorderRadius.circular(12),
                            color: theme.colorScheme.primary.withOpacity(0.4),
                          ),
                          child: const Icon(Icons.check, color: Colors.white),
                        ),
                      ),
                  ],
                ),
                title: _buildHighlightedText(
                    item.name,
                    provider.searchQuery,
                    TextStyle(fontWeight: FontWeight.w600, fontSize: 15, color: theme.colorScheme.onSurface)
                ),
                subtitle: Padding(
                  padding: const EdgeInsets.only(top: 4.0),
                  child: Row(
                    children: [
                      Expanded(
                        child: _buildHighlightedText(
                          subtitleText,
                          provider.searchQuery,
                          TextStyle(fontSize: 12, color: Colors.grey[600]),
                        ),
                      ),
                      if (incomplete) _buildIncompleteBadge(),
                    ],
                  ),
                ),
                trailing: _isSelectionMode
                    ? Checkbox(
                  value: isSelected,
                  onChanged: (_) => _toggleSelection(item.id!),
                  shape: const CircleBorder(),
                )
                    : Text(
                  NumberFormat.simpleCurrency(decimalDigits: 0).format(item.value),
                  style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.primary),
                ),
              ),
            ),
            const Divider(height: 1, indent: 86),
          ],
        );
      },
    );
  }

  Widget _buildActionDock(ThemeData theme) {
    return AnimatedPositioned(
      duration: const Duration(milliseconds: 350),
      curve: Curves.easeOutCubic,
      bottom: _showActions ? 0 : -140,
      left: 0,
      right: 0,
      child: Container(
        padding: const EdgeInsets.fromLTRB(20, 16, 20, 36),
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
          boxShadow: [
            BoxShadow(color: Colors.black.withOpacity(0.08), blurRadius: 20, offset: const Offset(0, -5)),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: InkWell(
                onTap: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const FastAddScreen())),
                child: Container(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant, borderRadius: BorderRadius.circular(16)),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.bolt_rounded, size: 20, color: theme.colorScheme.onSurfaceVariant),
                      const SizedBox(width: 8),
                      Text("FAST ADD", style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.onSurfaceVariant, letterSpacing: 0.5)),
                    ],
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              flex: 3,
              child: ElevatedButton.icon(
                onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const AddItemScreen())),
                style: ElevatedButton.styleFrom(
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                ),
                icon: const Icon(Icons.add_rounded),
                label: const Text("FULL ENTRY", style: TextStyle(fontWeight: FontWeight.bold, letterSpacing: 0.5)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildIncompleteBadge() {
    return Container(
      margin: const EdgeInsets.only(left: 8),
      padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1),
      decoration: BoxDecoration(
        color: Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: Colors.orange.withOpacity(0.3)),
      ),
      child: const Text("!", style: TextStyle(color: Colors.orange, fontSize: 10, fontWeight: FontWeight.bold)),
    );
  }
}

============================================================
PATH: .\lib\screens\item_detail_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Added for clipboard functionality
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'add_item_screen.dart';

class ItemDetailScreen extends StatelessWidget {
  final int itemId;
  const ItemDetailScreen({super.key, required this.itemId});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final provider = context.watch<InventoryProvider>();

    // Find item or return fallback
    final item = provider.items.firstWhere(
          (i) => i.id == itemId,
      orElse: () => Item(
        name: 'Deleted',
        imagePaths: [],
        value: 0,
        purchaseDate: DateTime.now(),
      ),
    );

    if (item.name == 'Deleted') {
      return const Scaffold(body: Center(child: Text("Item no longer exists.")));
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text("Item Details"),
        actions: [
          IconButton(
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'Edit Item',
            onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => AddItemScreen(itemToEdit: item)),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline),
            tooltip: 'Delete Item',
            onPressed: () => _confirmDelete(context, provider, item),
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildImageGallery(context, item),
            Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildHeader(theme, item),
                  const SizedBox(height: 24),

                  // Priority Insurance Info
                  if (item.warrantyExpiry != null) _buildWarrantyCard(theme, item),
                  if (item.serialNumber != null) _buildSerialCard(context, theme, item.serialNumber!),

                  const Divider(height: 40),

                  // Specifics Grid
                  _buildInfoGrid(theme, item),

                  const SizedBox(height: 24),
                  if (item.notes != null && item.notes!.isNotEmpty) _buildNotes(theme, item),
                  const SizedBox(height: 40),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- UI COMPONENTS ---

  Widget _buildImageGallery(BuildContext context, Item item) {
    if (item.imagePaths.isEmpty) return const SizedBox.shrink();
    return SizedBox(
      height: 320,
      child: PageView.builder(
        itemCount: item.imagePaths.length,
        itemBuilder: (context, index) {
          final bool isReceipt = item.receiptIndices.contains(index);
          return Stack(
            fit: StackFit.expand,
            children: [
              Image.file(File(item.imagePaths[index]), fit: BoxFit.cover),
              if (isReceipt)
                Positioned(
                  top: 16, right: 16,
                  child: Chip(
                    backgroundColor: Colors.green.withOpacity(0.9),
                    side: BorderSide.none,
                    label: const Text("RECEIPT", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 10)),
                    avatar: const Icon(Icons.receipt_long, color: Colors.white, size: 14),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildHeader(ThemeData theme, Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(item.name, style: theme.textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              NumberFormat.currency(symbol: "\$").format(item.value),
              style: theme.textTheme.headlineSmall?.copyWith(color: theme.colorScheme.primary, fontWeight: FontWeight.w600),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
              decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant, borderRadius: BorderRadius.circular(20)),
              child: Text(DateFormat('MMM d, yyyy').format(item.purchaseDate), style: theme.textTheme.bodySmall),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildWarrantyCard(ThemeData theme, Item item) {
    final now = DateTime.now();
    final isExpired = item.warrantyExpiry!.isBefore(now);
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: isExpired ? Colors.red.withOpacity(0.05) : Colors.green.withOpacity(0.05),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: isExpired ? Colors.red.shade200 : Colors.green.shade200),
      ),
      child: Row(
        children: [
          Icon(isExpired ? Icons.event_busy : Icons.verified_user_outlined, color: isExpired ? Colors.red : Colors.green),
          const SizedBox(width: 12),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(isExpired ? "Warranty Expired" : "Under Warranty",
                  style: TextStyle(fontWeight: FontWeight.bold, color: isExpired ? Colors.red.shade900 : Colors.green.shade900)),
              Text("Ended: ${DateFormat('MMM d, yyyy').format(item.warrantyExpiry!)}", style: const TextStyle(fontSize: 12)),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSerialCard(BuildContext context, ThemeData theme, String serial) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outlineVariant),
      ),
      child: Row(
        children: [
          const Icon(Icons.qr_code, size: 20, color: Colors.grey),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Serial Number", style: TextStyle(fontSize: 11, color: Colors.grey)),
                Text(serial, style: const TextStyle(fontFamily: 'monospace', fontWeight: FontWeight.w600)),
              ],
            ),
          ),
          IconButton(
            icon: const Icon(Icons.copy, size: 18),
            onPressed: () {
              Clipboard.setData(ClipboardData(text: serial));
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Serial copied to clipboard"), behavior: SnackBarBehavior.floating));
            },
          ),
        ],
      ),
    );
  }

  Widget _buildInfoGrid(ThemeData theme, Item item) {
    return Column(
      children: [
        Row(
          children: [
            Expanded(child: _buildInfoTile("Room", item.room ?? "General", Icons.room_outlined)),
            Expanded(child: _buildInfoTile("Category", item.category ?? "None", Icons.category_outlined)),
          ],
        ),
        const SizedBox(height: 20),
        Row(
          children: [
            Expanded(child: _buildInfoTile("Brand", item.brand ?? "N/A", Icons.factory_outlined)),
            Expanded(child: _buildInfoTile("Model", item.model ?? "N/A", Icons.label_important_outline)),
          ],
        ),
      ],
    );
  }

  Widget _buildInfoTile(String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 18, color: Colors.grey),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: const TextStyle(fontSize: 11, color: Colors.grey)),
              Text(value, style: const TextStyle(fontWeight: FontWeight.w500, fontSize: 14), overflow: TextOverflow.ellipsis),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildNotes(ThemeData theme, Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text("Notes & Description", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 8),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant.withOpacity(0.3), borderRadius: BorderRadius.circular(8)),
          child: Text(item.notes!, style: const TextStyle(height: 1.5)),
        ),
      ],
    );
  }

  void _confirmDelete(BuildContext context, InventoryProvider provider, Item item) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Delete Item?"),
        content: Text("This will permanently remove ${item.name} from your inventory."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
          FilledButton(
            style: FilledButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () {
              provider.deleteItem(item.id!);
              Navigator.pop(ctx);
              Navigator.pop(context);
            },
            child: const Text("DELETE"),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\list_management_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';

class ListManagementScreen extends StatelessWidget {
  final bool isRoom;
  const ListManagementScreen({super.key, required this.isRoom});

  @override
  Widget build(BuildContext context) {
    final provider = context.watch<InventoryProvider>();
    final items = isRoom ? provider.rooms : provider.categories;

    return Scaffold(
      appBar: AppBar(title: Text(isRoom ? 'Manage Rooms' : 'Manage Categories')),
      body: items.isEmpty
          ? const Center(child: Text('No items yet.'))
          : ListView.builder(
        itemCount: items.length,
        itemBuilder: (context, index) {
          final name = items[index];
          return ListTile(
            title: Text(name),
            trailing: IconButton(
              icon: const Icon(Icons.delete_outline, color: Colors.red),
              onPressed: () => _confirmDelete(context, name, provider),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => _showAddDialog(context, provider),
      ),
    );
  }

  void _showAddDialog(BuildContext context, InventoryProvider provider) {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(isRoom ? 'Add Room' : 'Add Category'),
        content: TextField(controller: controller, autofocus: true),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(
            onPressed: () {
              if (isRoom) provider.addRoom(controller.text);
              else provider.addCategory(controller.text);
              Navigator.pop(ctx);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _confirmDelete(BuildContext context, String name, InventoryProvider provider) {
    int count = isRoom ? provider.getItemsCountInRoom(name) : provider.getItemsCountInCategory(name);

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete?'),
        content: Text('"$name" is used by $count items. Remove from selection list?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('No')),
          TextButton(
            onPressed: () {
              if (isRoom) provider.removeRoom(name);
              else provider.removeCategory(name);
              Navigator.pop(ctx);
            },
            child: const Text('Yes'),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\settings_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import '../providers/inventory_provider.dart';
import '../providers/settings_provider.dart';
import '../services/zip_service.dart';
import '../services/demo_service.dart';
import 'list_management_screen.dart';
import 'dev_logs_screen.dart'; // <--- NEW IMPORT

const bool _showDebugOptions = true;

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  late TextEditingController _nameController;
  late TextEditingController _companyController;
  late TextEditingController _addressController;
  late TextEditingController _policyController;

  @override
  void initState() {
    super.initState();
    final settings = context.read<SettingsProvider>();
    _nameController = TextEditingController(text: settings.userName);
    _companyController = TextEditingController(text: settings.insuranceCompany);
    _addressController = TextEditingController(text: settings.address);
    _policyController = TextEditingController(text: settings.policyNumber);
  }

  @override
  void dispose() {
    _nameController.dispose();
    _companyController.dispose();
    _addressController.dispose();
    _policyController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsProvider = context.watch<SettingsProvider>();

    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          _buildSectionHeader(context, 'Insurance Profile'),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Column(
              children: [
                TextField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: "Policy Holder Name",
                    prefixIcon: Icon(Icons.person_outline),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _companyController,
                  decoration: const InputDecoration(
                    labelText: "Insurance Company",
                    prefixIcon: Icon(Icons.business_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _policyController,
                  decoration: const InputDecoration(
                    labelText: "Policy Number",
                    prefixIcon: Icon(Icons.description_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _addressController,
                  maxLines: 2,
                  decoration: const InputDecoration(
                    labelText: "Property Address",
                    prefixIcon: Icon(Icons.home_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: () {
                      settingsProvider.updateProfile(
                        _nameController.text,
                        _addressController.text,
                        _policyController.text,
                        _companyController.text,
                      );
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text("Profile Saved Successfully"), behavior: SnackBarBehavior.floating),
                      );
                    },
                    icon: const Icon(Icons.save),
                    label: const Text("Save Insurance Info"),
                  ),
                ),
              ],
            ),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Appearance'),
          ListTile(
            leading: const CircleAvatar(child: Icon(Icons.palette_outlined)),
            title: const Text("Theme Mode"),
            subtitle: Text("Currently: ${settingsProvider.themeMode.name.toUpperCase()}"),
            trailing: DropdownButton<ThemeMode>(
              value: settingsProvider.themeMode,
              onChanged: (ThemeMode? newMode) {
                if (newMode != null) settingsProvider.setThemeMode(newMode);
              },
              items: const [
                DropdownMenuItem(value: ThemeMode.system, child: Text("System")),
                DropdownMenuItem(value: ThemeMode.light, child: Text("Light")),
                DropdownMenuItem(value: ThemeMode.dark, child: Text("Dark")),
              ],
            ),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Data Management'),
          _buildTile(
            context,
            icon: Icons.cloud_upload_outlined,
            color: Colors.blue,
            title: 'Export Backup',
            subtitle: 'Create a .zip file with all data and photos',
            onTap: () async {
              final provider = Provider.of<InventoryProvider>(context, listen: false);
              final allImages = provider.items.expand((item) => item.imagePaths).toList();
              File? zip = await ZipService.createFullBackup(allImages);
              if (zip != null && context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Backup created at: ${zip.path}')));
              }
            },
          ),
          _buildTile(
            context,
            icon: Icons.file_download_outlined,
            color: Colors.orange,
            title: 'Import Backup',
            subtitle: 'Restore inventory from another device',
            onTap: () => _handleImport(context),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Organization'),
          _buildTile(
            context,
            icon: Icons.meeting_room_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Rooms',
            subtitle: 'Add or remove locations in your home',
            onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: true))),
          ),
          _buildTile(
            context,
            icon: Icons.style_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Categories',
            subtitle: 'Define item types (Electronics, Tools, etc.)',
            onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: false))),
          ),

          if (_showDebugOptions) ...[
            const Divider(),
            _buildSectionHeader(context, 'Developer Tools'),
            // --- NEW: LOG VIEWER TILE ---
            _buildTile(
              context,
              icon: Icons.bug_report_outlined,
              color: Colors.teal,
              title: 'System Logs',
              subtitle: 'View recent scan events and errors',
              onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const DevLogsScreen())),
            ),
            _buildTile(
              context,
              icon: Icons.auto_fix_high,
              color: Colors.purple,
              title: 'Load Demo Data',
              subtitle: 'Add sample items to test PDF and UI',
              onTap: () async {
                final provider = context.read<InventoryProvider>();
                await DemoService.populateDemoData(provider);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Demo data loaded!")));
                }
              },
            ),
            _buildTile(
              context,
              icon: Icons.delete_forever,
              color: Colors.red,
              title: 'Clear All Data',
              subtitle: 'Danger: Wipe entire inventory',
              onTap: () => _confirmClearAll(context),
            ),
          ],
          const SizedBox(height: 30),
        ],
      ),
    );
  }

  // --- HELPER METHODS (Unchanged from your snippet) ---
  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 20, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Theme.of(context).colorScheme.secondary, letterSpacing: 1.1),
      ),
    );
  }

  Widget _buildTile(BuildContext context, {required IconData icon, required Color color, required String title, required String subtitle, required VoidCallback onTap}) {
    return ListTile(
      leading: CircleAvatar(backgroundColor: color.withOpacity(0.1), child: Icon(icon, color: color)),
      title: Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
      subtitle: Text(subtitle, style: const TextStyle(fontSize: 12)),
      trailing: const Icon(Icons.chevron_right, size: 20),
      onTap: onTap,
    );
  }

  void _confirmClearAll(BuildContext context) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Wipe All Data?'),
        content: const Text('This will permanently delete your entire inventory. This action cannot be undone.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('CANCEL')),
          TextButton(
            onPressed: () {
              context.read<InventoryProvider>().clearAll();
              Navigator.pop(ctx);
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Inventory cleared.")));
            },
            child: const Text('CLEAR ALL', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  Future<void> _handleImport(BuildContext context) async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(type: FileType.custom, allowedExtensions: ['zip']);
    if (result == null) return;
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Restore Data?'),
        content: const Text('This will overwrite your current inventory. Continue?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('CANCEL')),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx);
              bool success = await ZipService.importBackup(File(result.files.single.path!));
              if (success) {
                await provider.refreshAfterImport();
              }
            },
            child: const Text('RESTORE'),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\services\backup_service.dart
============================================================

import 'dart:io';
import 'dart:convert';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../services/logger_service.dart'; // Import your logger

class BackupService {
  static Future<void> createAndShareBackup(BuildContext context) async {
    logger.log("--- Starting Backup Process ---");

    try {
      // 1. Fetch current items from the Provider
      final items = Provider.of<InventoryProvider>(context, listen: false).items;

      if (items.isEmpty) {
        logger.log("Backup Aborted: Inventory list is empty.");
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No items to export!')),
        );
        return;
      }

      logger.log("Exporting ${items.length} items to ZIP...");
      final archive = Archive();

      // 2. Create the JSON data file
      final List<Map<String, dynamic>> jsonData = items.map((i) => i.toMap()).toList();
      final String jsonString = jsonEncode(jsonData);
      final List<int> jsonBytes = utf8.encode(jsonString);
      archive.addFile(ArchiveFile('inventory_data.json', jsonBytes.length, jsonBytes));
      logger.log("Added inventory_data.json to archive.");

      // 3. Add ALL images to the ZIP
      int imageCount = 0;
      int missingFiles = 0;

      for (var item in items) {
        for (var imagePath in item.imagePaths) {
          final imageFile = File(imagePath);
          if (await imageFile.exists()) {
            final fileName = path.basename(imagePath);
            final bytes = await imageFile.readAsBytes();
            archive.addFile(ArchiveFile('images/$fileName', bytes.length, bytes));
            imageCount++;
          } else {
            missingFiles++;
            logger.log("Warning: Image not found at $imagePath (Item: ${item.name})");
          }
        }
      }
      logger.log("Added $imageCount images to archive. ($missingFiles files were missing from storage).");

      // 4. Save the ZIP file to temporary storage
      logger.log("Encoding ZIP file...");
      final zipEncoder = ZipEncoder();
      final List<int>? zipBytes = zipEncoder.encode(archive);

      if (zipBytes == null) {
        logger.log("Error: ZIP encoding failed (Returned null).");
        return;
      }

      final tempDir = await getTemporaryDirectory();
      final zipFile = File('${tempDir.path}/Home_Inventory_Backup.zip');
      await zipFile.writeAsBytes(zipBytes);

      final fileSizeMB = (await zipFile.length() / (1024 * 1024)).toStringAsFixed(2);
      logger.log("ZIP created successfully at ${zipFile.path} (Size: $fileSizeMB MB)");

      // 5. Trigger the Share Sheet
      logger.log("Opening Share Sheet...");
      final xFile = XFile(zipFile.path);
      await Share.shareXFiles(
        [xFile],
        text: 'My Home Inventory Backup (Insurance Data)',
      );
      logger.log("Backup process completed successfully.");

    } catch (e) {
      logger.log("CRITICAL BACKUP ERROR", error: e);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Backup failed: $e')),
        );
      }
    }
  }
}

============================================================
PATH: .\lib\services\demo_service.dart
============================================================

import '../models/item.dart';
import '../providers/inventory_provider.dart';

class DemoService {
  static Future<void> populateDemoData(InventoryProvider provider) async {
    final List<Item> demoItems = [
      Item(
        name: "MacBook Pro 16",
        brand: "Apple",
        model: "M3 Max",
        serialNumber: "SN-DEMO-9921",
        value: 2499.00,
        room: "Office",
        category: "Electronics",
        purchaseDate: DateTime.now().subtract(const Duration(days: 200)),
        warrantyExpiry: DateTime.now().add(const Duration(days: 165)),
        notes: "Primary work machine. Includes power adapter and leather sleeve.",
        imagePaths: [], // Note: Photos won't appear unless you manually add local asset paths
      ),
      Item(
        name: "Sony 65\" OLED TV",
        brand: "Sony",
        model: "A80J",
        serialNumber: "SN-TV-55123",
        value: 1800.00,
        room: "Living Room",
        category: "Electronics",
        purchaseDate: DateTime.now().subtract(const Duration(days: 400)),
        warrantyExpiry: DateTime.now().subtract(const Duration(days: 35)), // Expired
        notes: "Mounted on wall bracket.",
        imagePaths: [],
      ),
      Item(
        name: "Engagement Ring",
        brand: "Tiffany & Co.",
        model: "Setting Platinum",
        value: 8500.00,
        room: "Bedroom",
        category: "Jewelry",
        purchaseDate: DateTime.now().subtract(const Duration(days: 1000)),
        notes: "High value - check specific insurance rider.",
        imagePaths: [],
      ),
      Item(
        name: "Coffee Table",
        brand: "West Elm",
        model: "Mid-Century Modern",
        value: 450.00,
        room: "Living Room",
        category: "Furniture",
        purchaseDate: DateTime.now().subtract(const Duration(days: 60)),
        imagePaths: [],
      ),
    ];

    for (var item in demoItems) {
      await provider.addItem(item);
    }
  }
}

============================================================
PATH: .\lib\services\export_service.dart
============================================================

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import '../models/item.dart';
import '../services/logger_service.dart'; // Import your logger

class ExportService {
  static Future<void> shareAsJson(List<Item> items) async {
    logger.log("Export: Starting JSON generation for ${items.length} items...");

    try {
      final jsonData = items.map((i) => i.toMap()).toList();
      final directory = await getTemporaryDirectory();
      final file = File('${directory.path}/inventory_export.json');

      await file.writeAsString(jsonEncode(jsonData));

      final fileSize = await file.length();
      logger.log("Export: JSON file written (${fileSize} bytes). Opening share sheet.");

      await Share.shareXFiles([XFile(file.path)], text: 'Inventory JSON Backup');
      logger.log("Export: JSON Share sheet closed.");
    } catch (e) {
      logger.log("EXPORT ERROR (JSON)", error: e);
      rethrow;
    }
  }

  static Future<void> shareAsCsv(List<Item> items) async {
    logger.log("Export: Starting CSV generation for ${items.length} items...");

    try {
      List<List<dynamic>> rows = [
        ["Name", "Value", "Room", "Category", "Purchase Date", "Brand", "Model", "Serial", "Notes"]
      ];

      for (var i in items) {
        rows.add([
          i.name,
          i.value,
          i.room ?? "",
          i.category ?? "",
          i.purchaseDate.toIso8601String(),
          i.brand ?? "",
          i.model ?? "",
          i.serialNumber ?? "",
          i.notes ?? ""
        ]);
      }

      final csvData = const ListToCsvConverter().convert(rows);
      final directory = await getTemporaryDirectory();
      final file = File('${directory.path}/inventory_export.csv');

      await file.writeAsString(csvData);

      logger.log("Export: CSV file written to ${file.path}. Total rows: ${rows.length}");

      await Share.shareXFiles([XFile(file.path)], text: 'Inventory CSV Export');
      logger.log("Export: CSV Share sheet closed.");
    } catch (e) {
      logger.log("EXPORT ERROR (CSV)", error: e);
      rethrow;
    }
  }
}

============================================================
PATH: .\lib\services\logger_service.dart
============================================================

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class LoggerService {
  // Singleton pattern
  static final LoggerService _instance = LoggerService._internal();
  factory LoggerService() => _instance;
  LoggerService._internal();

  final List<String> _logs = [];
  List<String> get logs => List.unmodifiable(_logs);

  void log(String message, {dynamic error, StackTrace? stack}) {
    final timestamp = DateFormat('HH:mm:ss').format(DateTime.now());
    final logEntry = "[$timestamp] $message ${error ?? ''}";

    _logs.insert(0, logEntry); // Newest first
    debugPrint(logEntry); // Still print to console

    if (stack != null) {
      _logs.insert(0, "STACKTRACE: ${stack.toString().split('\n').take(3).join('\n')}");
    }

    // Keep only the last 100 logs to save memory
    if (_logs.length > 100) _logs.removeRange(100, _logs.length);
  }

  void clear() => _logs.clear();
}

final logger = LoggerService();

============================================================
PATH: .\lib\services\pdf_service.dart
============================================================

import 'dart:io';
import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../models/item.dart';
import '../providers/settings_provider.dart';
import '../services/logger_service.dart'; // Import your logger

class PdfService {
  /// Generates a professional PDF report including insurance profile details,
  /// a summary table, a photo appendix, and high-value detail pages.
  static Future<void> generateInventoryReport(List<Item> items, SettingsProvider settings) async {
    logger.log("PDF: Starting report generation for ${items.length} items...");

    try {
      final pdf = pw.Document();
      final NumberFormat currencyFormat = NumberFormat.simpleCurrency();
      final DateTime now = DateTime.now();

      // 1. Calculate Summary Data
      double totalValue = items.fold(0, (sum, item) => sum + item.value);
      logger.log("PDF: Calculated total value: ${currencyFormat.format(totalValue)}");

      // --- PAGE 1: PROFESSIONAL COVER & SUMMARY TABLE ---
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(32),
          build: (context) => [
            // Personalized Insurance Header
            pw.Row(
              mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: [
                    pw.Text(
                      settings.userName.isEmpty ? "HOME INVENTORY REPORT" : settings.userName.toUpperCase(),
                      style: pw.TextStyle(fontSize: 18, fontWeight: pw.FontWeight.bold),
                    ),
                    if (settings.address.isNotEmpty)
                      pw.Padding(
                        padding: const pw.EdgeInsets.only(top: 2),
                        child: pw.Text(settings.address, style: const pw.TextStyle(fontSize: 10)),
                      ),
                    pw.SizedBox(height: 8),
                    pw.Text(
                      "INSURER: ${settings.insuranceCompany.isEmpty ? 'NOT SPECIFIED' : settings.insuranceCompany.toUpperCase()}",
                      style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold),
                    ),
                    pw.Text(
                      "POLICY #: ${settings.policyNumber.isEmpty ? 'N/A' : settings.policyNumber}",
                      style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold),
                    ),
                    pw.SizedBox(height: 4),
                    pw.Text(
                      "Generated on: ${DateFormat.yMMMMd().format(now)}",
                      style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey700),
                    ),
                  ],
                ),
                pw.Container(
                  padding: const pw.EdgeInsets.all(12),
                  decoration: const pw.BoxDecoration(
                    color: PdfColors.grey100,
                    borderRadius: pw.BorderRadius.all(pw.Radius.circular(4)),
                  ),
                  child: pw.Column(
                    children: [
                      pw.Text("TOTAL ESTIMATED VALUE", style: const pw.TextStyle(fontSize: 8)),
                      pw.Text(
                        currencyFormat.format(totalValue),
                        style: pw.TextStyle(
                          fontSize: 18,
                          fontWeight: pw.FontWeight.bold,
                          color: PdfColors.green900,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
            pw.SizedBox(height: 20),
            pw.Divider(thickness: 0.5, color: PdfColors.grey400),
            pw.SizedBox(height: 10),

            pw.Text("Inventory Overview", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
            pw.SizedBox(height: 10),

            // Summary Table
            pw.Table.fromTextArray(
              headerStyle: pw.TextStyle(fontWeight: pw.FontWeight.bold, color: PdfColors.white),
              headerDecoration: const pw.BoxDecoration(color: PdfColors.blueGrey900),
              cellHeight: 25,
              columnWidths: {
                0: const pw.FlexColumnWidth(3), // Name
                1: const pw.FlexColumnWidth(2), // Location
                2: const pw.FlexColumnWidth(2), // Date
                3: const pw.FlexColumnWidth(2), // Value
              },
              headers: ['Item Name', 'Location', 'Purchase Date', 'Value'],
              data: items.map((item) => [
                item.name,
                "${item.room ?? 'N/A'}\n(${item.category ?? 'N/A'})",
                DateFormat.yMMMd().format(item.purchaseDate),
                currencyFormat.format(item.value),
              ]).toList(),
            ),
          ],
        ),
      );
      logger.log("PDF: Cover page and summary table generated.");

      // --- APPENDIX: PHOTO EVIDENCE GRID ---
      logger.log("PDF: Processing image appendix...");
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          build: (context) => [
            pw.Header(level: 0, text: "Photo Evidence Appendix"),
            pw.SizedBox(height: 10),
            pw.GridView(
              crossAxisCount: 2,
              childAspectRatio: 0.8,
              children: items.map((item) {
                return pw.Container(
                  padding: const pw.EdgeInsets.all(5),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Expanded(
                        child: item.imagePaths.isNotEmpty
                            ? _buildPdfImage(item.imagePaths[0], item.name)
                            : pw.Container(color: PdfColors.grey300),
                      ),
                      pw.SizedBox(height: 5),
                      pw.Text(item.name, style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
                      pw.Text(
                        "${item.room ?? 'General'} | ${currencyFormat.format(item.value)}",
                        style: const pw.TextStyle(fontSize: 8),
                      ),
                    ],
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      );

      // --- HIGH VALUE DETAIL PAGES ---
      final highValueItems = items.where((i) => i.value >= 1000).toList();
      if (highValueItems.isNotEmpty) {
        logger.log("PDF: Generating ${highValueItems.length} high-value detail pages.");
        for (var item in highValueItems) {
          pdf.addPage(
            pw.Page(
              build: (context) => pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Header(level: 0, text: "High Value Asset: ${item.name}"),
                  pw.Row(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Expanded(
                        flex: 1,
                        child: pw.Column(
                          crossAxisAlignment: pw.CrossAxisAlignment.start,
                          children: [
                            _detailRow("Value", currencyFormat.format(item.value)),
                            _detailRow("Brand", item.brand ?? "N/A"),
                            _detailRow("Model", item.model ?? "N/A"),
                            _detailRow("Serial #", item.serialNumber ?? "N/A"),
                            _detailRow("Purchase Date", DateFormat.yMMMMd().format(item.purchaseDate)),
                          ],
                        ),
                      ),
                      pw.SizedBox(width: 20),
                      pw.Expanded(
                        flex: 1,
                        child: item.imagePaths.isNotEmpty
                            ? _buildPdfImage(item.imagePaths[0], "Detail: ${item.name}")
                            : pw.Container(),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          );
        }
      }

      logger.log("PDF: Document complete. Sending to OS print spooler...");
      await Printing.layoutPdf(onLayout: (PdfPageFormat format) async => pdf.save());
      logger.log("PDF: Printing/Saving UI closed.");

    } catch (e) {
      logger.log("CRITICAL PDF ERROR", error: e);
      rethrow;
    }
  }

  /// Helper to handle image reading with logging
  static pw.Widget _buildPdfImage(String imagePath, String itemName) {
    try {
      final file = File(imagePath);
      if (file.existsSync()) {
        return pw.Image(
          pw.MemoryImage(file.readAsBytesSync()),
          fit: pw.BoxFit.cover,
        );
      } else {
        logger.log("PDF Warning: Image file missing for $itemName at $imagePath");
        return pw.Container(color: PdfColors.grey300);
      }
    } catch (e) {
      logger.log("PDF Error: Failed to process image for $itemName", error: e);
      return pw.Container(color: PdfColors.red100);
    }
  }

  static pw.Widget _detailRow(String label, String value) {
    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 2),
      child: pw.RichText(
        text: pw.TextSpan(
          children: [
            pw.TextSpan(text: "$label: ", style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
            pw.TextSpan(text: value, style: const pw.TextStyle(fontSize: 10)),
          ],
        ),
      ),
    );
  }
}

============================================================
PATH: .\lib\services\zip_service.dart
============================================================

import 'dart:io';
import 'package:archive/archive_io.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import '../services/logger_service.dart'; // Import your logger

class ZipService {
  static Future<String> _getDatabasePath() async {
    final dbFolder = await getDatabasesPath();
    return p.join(dbFolder, 'inventory.db');
  }

  /// The main method used by your UI/Provider to create a .zip backup
  static Future<File?> createFullBackup(List<String> allImagePaths) async {
    logger.log("Backup: Starting ZIP creation...");

    try {
      final encoder = ZipFileEncoder();
      final tempDir = await getTemporaryDirectory();
      final zipPath = p.join(tempDir.path, 'inventory_backup.zip');

      encoder.create(zipPath);

      // 1. Add the Database File
      final dbFilePath = await _getDatabasePath();
      final dbFile = File(dbFilePath);

      if (dbFile.existsSync()) {
        encoder.addFile(dbFile);
        logger.log("Backup: Database file added to ZIP.");
      } else {
        logger.log("Backup ERROR: Database file not found at $dbFilePath");
      }

      // 2. Add Images
      int imageCount = 0;
      for (String path in allImagePaths) {
        if (path.isEmpty) continue;

        final imgFile = File(path);
        if (imgFile.existsSync()) {
          encoder.addFile(imgFile);
          imageCount++;
        } else {
          logger.log("Backup Warning: Skipping missing image at $path");
        }
      }

      encoder.close();
      final finalFile = File(zipPath);
      final sizeMB = (await finalFile.length() / (1024 * 1024)).toStringAsFixed(2);

      logger.log("Backup: Success! Added $imageCount images. Total size: $sizeMB MB");
      return finalFile;
    } catch (e) {
      logger.log("CRITICAL BACKUP FAILURE", error: e);
      return null;
    }
  }

  /// Restores database and images from a selected .zip file
  static Future<bool> importBackup(File zipFile) async {
    logger.log("Import: Starting restoration from ${zipFile.path}");

    try {
      final bytes = await zipFile.readAsBytes();
      final archive = ZipDecoder().decodeBytes(bytes);
      final appDir = await getApplicationDocumentsDirectory();
      final dbPath = await _getDatabasePath();

      int filesRestored = 0;

      for (final file in archive) {
        final filename = file.name;
        if (file.isFile) {
          final data = file.content as List<int>;

          if (filename == 'inventory.db') {
            logger.log("Import: Detected database file. Overwriting current DB...");

            // Handle Database Restore with safety temp file
            final tempDb = File('$dbPath.tmp');
            await tempDb.writeAsBytes(data);

            // Close existing connection before overwriting (via databaseFactory)
            await databaseFactory.deleteDatabase(dbPath);
            await tempDb.rename(dbPath);
            logger.log("Import: Database successfully replaced.");
          } else {
            // Handle Images Restore
            final outFile = File(p.join(appDir.path, filename));
            await outFile.create(recursive: true);
            await outFile.writeAsBytes(data);
            filesRestored++;
          }
        }
      }

      logger.log("Import: SUCCESS. Restored database and $filesRestored images.");
      return true;
    } catch (e) {
      logger.log("IMPORT FAILURE", error: e);
      return false;
    }
  }
}

============================================================
PATH: .\lib\widgets\barcode_scanner.dart
============================================================

import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import '../services/logger_service.dart';

class BarcodeScannerWidget extends StatefulWidget {
  const BarcodeScannerWidget({super.key});

  @override
  State<BarcodeScannerWidget> createState() => _BarcodeScannerWidgetState();
}

class _BarcodeScannerWidgetState extends State<BarcodeScannerWidget> {
  // MobileScannerController allows us to control the flash or switch cameras
  MobileScannerController cameraController = MobileScannerController();

  @override
  void dispose() {
    cameraController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan Serial Number'),
        actions: [
          // Flashlight toggle
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: cameraController,
              builder: (context, state, child) {
                switch (state.torchState) {
                  case TorchState.off:
                    return const Icon(Icons.flash_off, color: Colors.grey);
                  case TorchState.on:
                    return const Icon(Icons.flash_on, color: Colors.yellow);
                  case TorchState.auto:
                    return const Icon(Icons.flash_auto, color: Colors.blueAccent);
                  case TorchState.unavailable:
                    return const Icon(Icons.flash_off, color: Colors.black26);
                }
              },
            ),
            onPressed: () => cameraController.toggleTorch(),
          ),
        ],
      ),
      body: MobileScanner(
        controller: cameraController,
        onDetect: (BarcodeCapture capture) {
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty) {
            final String code = barcodes.first.rawValue ?? "Unknown";

            // Log the successful scan
            logger.log("Barcode Scanned successfully: $code");

            Navigator.pop(context, code);
          } else {
            logger.log("Scanner triggered but no barcode data detected.");
          }
        },
      ),
    );
  }
}

============================================================
PATH: .\test\widget_test.dart
============================================================

