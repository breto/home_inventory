FLUTTER PROJECT CODEBASE BUNDLE
Generated for Gemini Analysis


============================================================
PATH: .\analysis_options.yaml
============================================================

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


============================================================
PATH: .\devtools_options.yaml
============================================================

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:


============================================================
PATH: .\pubspec.yaml
============================================================

name: home_inventory
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.8

# Section 1: Packages your app NEEDS to run
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.1.1
  sqflite: ^2.3.0
  path: ^1.8.3
  image_picker: ^1.0.4
  path_provider: ^2.1.1
  intl: ^0.20.2
  archive: ^4.0.7
  share_plus: ^12.0.1
  shared_preferences: ^2.5.4
  pdf: ^3.10.7
  printing: ^5.11.1
  flutter_image_compress: ^2.3.0
  mobile_scanner: ^5.2.0

# Section 2: Tools for you (the developer) only
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true

============================================================
PATH: .\lib\main.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'providers/inventory_provider.dart';
import 'screens/home_screen.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      create: (context) => InventoryProvider()..fetchItems(),
      child: MaterialApp(
        title: 'Home Inventory',
        theme: ThemeData(
          primarySwatch: Colors.blue,
          useMaterial3: true,
        ),
        home: const HomeScreen(),
      ),
    );
  }
}

============================================================
PATH: .\lib\data\database_helper.dart
============================================================

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/item.dart';
import 'dart:developer' as dev;

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  // Point 9: Consistent naming and versioning
  static const String _dbName = 'inventory.db';
  static const int _dbVersion = 3;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB(_dbName);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: _dbVersion,
      onCreate: _createDB,
      onUpgrade: _onUpgrade, // Point 5: Migration support
    );
  }

  Future _createDB(Database db, int version) async {
    const idType = 'INTEGER PRIMARY KEY AUTOINCREMENT';
    const textType = 'TEXT NOT NULL';
    const textNullable = 'TEXT';
    const doubleType = 'REAL NOT NULL';

    await db.execute('''
CREATE TABLE items (
  id $idType,
  name $textType,
  value $doubleType,
  purchaseDate $textType,
  imagePaths $textType,
  room $textNullable,
  category $textNullable,
  serialNumber $textNullable,
  brand $textNullable,
  model $textNullable,
  notes $textNullable
)
    ''');
  }

  // Point 5: Handle future database changes without wiping user data
  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    dev.log("Upgrading database from $oldVersion to $newVersion");
    if (oldVersion < 3) {
      // Future migration logic goes here
    }
  }

  Future<int> create(Item item) async {
    try {
      final db = await instance.database;
      return await db.insert('items', item.toMap());
    } catch (e) {
      // Point 10: Better error context
      dev.log("Database Error (Create): $e");
      rethrow; // Rethrow so the Provider/UI can catch and show a message
    }
  }

  Future<List<Item>> readAllItems() async {
    final db = await instance.database;
    final result = await db.query('items', orderBy: 'name ASC');
    return result.map((json) => Item.fromMap(json)).toList();
  }

  Future<int> update(Item item) async {
    final db = await instance.database;
    return db.update(
      'items',
      item.toMap(),
      where: 'id = ?',
      whereArgs: [item.id],
    );
  }

  Future<int> delete(int id) async {
    final db = await instance.database;
    return await db.delete(
      'items',
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  // Point 5: Add a close method for clean app termination/testing
  Future close() async {
    final db = await _database;
    if (db != null) {
      await db.close();
    }
  }
}

============================================================
PATH: .\lib\models\item.dart
============================================================

import 'dart:convert';

class Item {
  final int? id;
  final String name;
  final List<String> imagePaths; // Updated to List
  final double value;
  final DateTime purchaseDate;

  // New insurance-focused fields
  final String? serialNumber;
  final String? brand;
  final String? model;
  final String? notes;
  final String? room;
  final String? category;

  Item({
    this.id,
    required this.name,
    required this.imagePaths,
    required this.value,
    required this.purchaseDate,
    this.serialNumber,
    this.brand,
    this.model,
    this.notes,
    this.room,
    this.category,
  });

  // Convert an Item object into a Map to store in SQLite
  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      // Convert the List ["p1", "p2"] into a single String '["p1", "p2"]'
      'imagePaths': jsonEncode(imagePaths),
      'value': value,
      'purchaseDate': purchaseDate.toIso8601String(),
      'serialNumber': serialNumber,
      'brand': brand,
      'model': model,
      'notes': notes,
      'room': room,
      'category': category,
    };
  }

  // Create an Item object from a Map (fetched from SQLite)
  factory Item.fromMap(Map<String, dynamic> map) {
    return Item(
      id: map['id'] as int?,
      name: map['name'] ?? '',
      value: (map['value'] as num?)?.toDouble() ?? 0.0,
      purchaseDate: map['purchaseDate'] != null
          ? DateTime.tryParse(map['purchaseDate']) ?? DateTime.now()
          : DateTime.now(),
      imagePaths: map['imagePaths'] != null
          ? List<String>.from(jsonDecode(map['imagePaths']))
          : [],
      room: map['room'],
      category: map['category'],
      serialNumber: map['serialNumber'],
      brand: map['brand'],
      model: map['model'],
      notes: map['notes'],
    );
  }
}

============================================================
PATH: .\lib\providers\inventory_provider.dart
============================================================

import 'package:flutter/material.dart';
import '../models/item.dart';
import '../data/database_helper.dart';

class InventoryProvider with ChangeNotifier {
  List<Item> _items = [];
  bool _isLoading = false;

  List<Item> get items => _items;
  bool get isLoading => _isLoading;

  String _searchQuery = '';

  String get searchQuery => _searchQuery;

  void setSearchQuery(String query) {
    _searchQuery = query;
    notifyListeners(); // This triggers the UI to rebuild with the filtered results
  }

  List<Item> get filteredItems {
    if (_searchQuery.isEmpty) return _items;
    return _items.where((item) {
      final searchLower = _searchQuery.toLowerCase();
      final nameMatch = item.name.toLowerCase().contains(searchLower);
      final roomMatch = (item.room ?? '').toLowerCase().contains(searchLower);
      final categoryMatch = (item.category ?? '').toLowerCase().contains(searchLower);
      return nameMatch || roomMatch || categoryMatch;
    }).toList();
  }

  int getItemCountByRoom(String roomName) {
    return _items.where((item) => item.room == roomName).length;
  }

  int getItemCountByCategory(String categoryName) {
    return _items.where((item) => item.category == categoryName).length;
  }

  // Calculates the total value for the AppBar chip
  double get totalValue {
    return _items.fold(0.0, (sum, item) => sum + item.value);
  }

  // Load all items from SQLite
  Future<void> fetchItems() async {
    _isLoading = true;
    notifyListeners();

    try {
      _items = await DatabaseHelper.instance.readAllItems();
    } catch (e) {
      debugPrint('Error fetching items: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // Add a new item and refresh the list
  Future<void> addItem(Item item) async {
    await DatabaseHelper.instance.create(item);
    await fetchItems(); // Refresh the list from the source of truth
  }

  // Delete an item and refresh
  Future<void> deleteItem(int id) async {
    await DatabaseHelper.instance.delete(id);
    await fetchItems();
  }

  int getItemsCountInRoom(String roomName) {
    return _items.where((item) => item.room == roomName).length;
  }

  int getItemsCountInCategory(String categoryName) {
    return _items.where((item) => item.category == categoryName).length;
  }

  Future<void> updateItem(Item item) async {
    await DatabaseHelper.instance.update(item);
    await fetchItems(); // Refresh the list so the UI shows the new data
  }

}

============================================================
PATH: .\lib\screens\add_item_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:provider/provider.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import '../services/preferences_service.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import '../widgets/barcode_scanner.dart';

class AddItemScreen extends StatefulWidget {
  final Item? itemToEdit;
  const AddItemScreen({super.key, this.itemToEdit});

  @override
  State<AddItemScreen> createState() => _AddItemScreenState();
}

class _AddItemScreenState extends State<AddItemScreen> {
  final _formKey = GlobalKey<FormState>();
  final _prefs = PreferencesService();

  // Text Controllers
  final _nameController = TextEditingController();
  final _valueController = TextEditingController();
  final _serialController = TextEditingController();
  final _brandController = TextEditingController();
  final _modelController = TextEditingController();
  final _notesController = TextEditingController();

  // State Management
  List<File> _imageFiles = [];
  List<String> _rooms = [];
  List<String> _categories = [];
  String? _selectedRoom;
  String? _selectedCategory;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();

    // 1. If editing, populate values immediately to avoid UI flickering
    if (widget.itemToEdit != null) {
      final item = widget.itemToEdit!;
      _nameController.text = item.name;
      _valueController.text = item.value.toString();
      _serialController.text = item.serialNumber ?? '';
      _brandController.text = item.brand ?? '';
      _modelController.text = item.model ?? '';
      _notesController.text = item.notes ?? '';
      _selectedRoom = item.room;
      _selectedCategory = item.category;
      _imageFiles = item.imagePaths.map((path) => File(path)).toList();
    }

    // 2. Load preferences asynchronously
    _loadPreferences();
  }

  @override
  void dispose() {
    // FIX (Point 1): Prevent memory leaks by disposing all controllers
    _nameController.dispose();
    _valueController.dispose();
    _serialController.dispose();
    _brandController.dispose();
    _modelController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _loadPreferences() async {
    final r = await _prefs.getRooms();
    final c = await _prefs.getCategories();

    if (!mounted) return;

    setState(() {
      _rooms = r;
      _categories = c;

      // FIX (Point 2): Prevent clobbering. Only set defaults if selection is null.
      if (_selectedRoom == null && _rooms.isNotEmpty) {
        _selectedRoom = _rooms[0];
      }
      if (_selectedCategory == null && _categories.isNotEmpty) {
        _selectedCategory = _categories[0];
      }
    });
  }

  Future<void> _pickImage(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: source, imageQuality: 75);

    if (pickedFile != null) {
      setState(() {
        _imageFiles.add(File(pickedFile.path));
      });
    }
  }

  Future<void> _saveItem() async {
    if (_isSaving) return;
    if (!_formKey.currentState!.validate()) return;

    if (_imageFiles.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Please add at least one photo for insurance proof.')),
      );
      return;
    }

    setState(() => _isSaving = true);

    try {
      final appDir = await getApplicationDocumentsDirectory();
      List<String> savedPaths = [];

      for (var file in _imageFiles) {
        // If file is already internal (Editing), don't re-compress
        if (file.path.contains(appDir.path)) {
          savedPaths.add(file.path);
        } else {
          final fileName = 'img_${DateTime.now().millisecondsSinceEpoch}_${path.basename(file.path)}';
          final targetPath = '${appDir.path}/$fileName';

          var result = await FlutterImageCompress.compressAndGetFile(
            file.absolute.path,
            targetPath,
            quality: 70,
            minWidth: 1024,
            minHeight: 1024,
          );

          if (result != null) {
            savedPaths.add(result.path);
          } else {
            final savedImage = await file.copy(targetPath);
            savedPaths.add(savedImage.path);
          }
        }
      }

      final newItem = Item(
        id: widget.itemToEdit?.id,
        name: _nameController.text,
        imagePaths: savedPaths,
        value: double.tryParse(_valueController.text.replaceAll(',', '')) ?? 0.0,
        purchaseDate: widget.itemToEdit?.purchaseDate ?? DateTime.now(),
        serialNumber: _serialController.text,
        brand: _brandController.text,
        model: _modelController.text,
        notes: _notesController.text,
        room: _selectedRoom,
        category: _selectedCategory,
      );

      final provider = Provider.of<InventoryProvider>(context, listen: false);
      if (widget.itemToEdit == null) {
        await provider.addItem(newItem);
      } else {
        await provider.updateItem(newItem);
      }

      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error saving: $e')));
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    // FIX (Point 15): Access the app theme for consistent UI colors
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(title: Text(widget.itemToEdit == null ? 'Add Item Details' : 'Edit Item')),
      body: _isSaving
          ? const Center(child: CircularProgressIndicator())
          : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            children: [
              // PHOTO GALLERY
              SizedBox(
                height: 120,
                child: ListView.builder(
                  scrollDirection: Axis.horizontal,
                  itemCount: _imageFiles.length + 1,
                  itemBuilder: (ctx, i) {
                    if (i == _imageFiles.length) return _buildAddPhotoButton();
                    return _buildPhotoPreview(i);
                  },
                ),
              ),
              const SizedBox(height: 20),

              _buildTextField(_nameController, 'Item Name', Icons.inventory_2),
              _buildTextField(_valueController, 'Estimated Value (\$)', Icons.monetization_on, isNumber: true),

              Row(
                children: [
                  Expanded(child: _buildDropdown('Room', _selectedRoom, _rooms, (val) => setState(() => _selectedRoom = val))),
                  const SizedBox(width: 10),
                  Expanded(child: _buildDropdown('Category', _selectedCategory, _categories, (val) => setState(() => _selectedCategory = val))),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildTextField(_brandController, 'Brand', Icons.factory)),
                  const SizedBox(width: 10),
                  Expanded(child: _buildTextField(_modelController, 'Model #', Icons.label_important)),
                ],
              ),

              _buildScanTextField(_serialController, 'Serial Number / UPC', Icons.qr_code_scanner),
              _buildTextField(_notesController, 'Notes / Description', Icons.description, maxLines: 3),

              const SizedBox(height: 30),

              ElevatedButton.icon(
                onPressed: _saveItem,
                icon: const Icon(Icons.check_circle),
                label: Text(widget.itemToEdit == null ? 'SAVE TO INVENTORY' : 'UPDATE ITEM', style: const TextStyle(fontSize: 16)),
                style: ElevatedButton.styleFrom(
                  minimumSize: const Size(double.infinity, 55),
                  // Using theme colors
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // --- UI HELPERS ---

  Widget _buildScanTextField(TextEditingController controller, String label, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
          prefixIcon: Icon(icon),
          suffixIcon: IconButton(
            icon: Icon(Icons.camera_alt, color: Theme.of(context).colorScheme.primary),
            tooltip: 'Scan Barcode',
            onPressed: () async {
              final String? scannedCode = await Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const BarcodeScannerWidget()),
              );
              if (scannedCode != null && mounted) {
                setState(() => controller.text = scannedCode);
              }
            },
          ),
          border: const OutlineInputBorder(),
        ),
      ),
    );
  }

  Widget _buildTextField(TextEditingController controller, String label, IconData icon, {bool isNumber = false, int maxLines = 1}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: TextFormField(
        controller: controller,
        maxLines: maxLines,
        keyboardType: isNumber ? const TextInputType.numberWithOptions(decimal: true) : TextInputType.text,
        decoration: InputDecoration(
          labelText: label,
          prefixIcon: Icon(icon),
          border: const OutlineInputBorder(),
        ),
        validator: (v) => v == null || v.isEmpty ? 'Please enter $label' : null,
      ),
    );
  }

  Widget _buildDropdown(String label, String? value, List<String> items, Function(String?) onChanged) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: DropdownButtonFormField<String>(
        value: value,
        decoration: InputDecoration(labelText: label, border: const OutlineInputBorder()),
        items: items.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildPhotoPreview(int index) {
    return Stack(
      children: [
        Container(
          margin: const EdgeInsets.only(right: 12),
          width: 100,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            image: DecorationImage(image: FileImage(_imageFiles[index]), fit: BoxFit.cover),
            border: Border.all(color: Theme.of(context).colorScheme.primary.withOpacity(0.3)),
          ),
        ),
        Positioned(
          right: 5,
          top: -5,
          child: GestureDetector(
            onTap: () => setState(() => _imageFiles.removeAt(index)),
            child: const CircleAvatar(
              radius: 12,
              backgroundColor: Colors.red,
              child: Icon(Icons.close, size: 16, color: Colors.white),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildAddPhotoButton() {
    final theme = Theme.of(context);
    return GestureDetector(
      onTap: () => _showPickerOptions(),
      child: Container(
        width: 100,
        decoration: BoxDecoration(
          color: theme.colorScheme.surfaceVariant,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.colorScheme.outlineVariant),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.add_a_photo, color: theme.colorScheme.primary),
            const SizedBox(height: 4),
            Text("Add Photo", style: TextStyle(fontSize: 12, color: theme.colorScheme.primary)),
          ],
        ),
      ),
    );
  }

  void _showPickerOptions() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) => Padding(
        padding: const EdgeInsets.symmetric(vertical: 20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.camera_alt),
              title: const Text('Take Photo with Camera'),
              onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.camera); },
            ),
            ListTile(
              leading: const Icon(Icons.photo_library),
              title: const Text('Import from Gallery'),
              onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.gallery); },
            ),
          ],
        ),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\home_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:home_inventory/screens/add_item_screen.dart';
import 'package:home_inventory/screens/item_detail_screen.dart';
import 'package:home_inventory/screens/settings_screen.dart';
import 'package:home_inventory/services/pdf_service.dart';
import 'package:home_inventory/services/zip_service.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/inventory_provider.dart';


class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _showExportMenu(BuildContext context) {
    final provider = Provider.of<InventoryProvider>(context, listen: false);

    showModalBottomSheet(
      context: context,
      builder: (ctx) => SafeArea(
        child: Wrap(
          children: [
            ListTile(
              leading: const Icon(Icons.picture_as_pdf, color: Colors.red),
              title: const Text('Export PDF Report'),
              subtitle: const Text('Best for insurance claims'),
              onTap: () {
                Navigator.pop(ctx);
                PdfService.generateInventoryReport(provider.items);
              },
            ),
            ListTile(
              leading: const Icon(Icons.folder_zip, color: Colors.orange),
              title: const Text('Export ZIP Backup'),
              subtitle: const Text('Includes all full-resolution photos'),
              onTap: () {
                Navigator.pop(ctx);
                final allImages = provider.items.expand((item) => item.imagePaths).toList();
                ZipService.createFullBackup(allImages);
              },
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    // listen: false here because we use Consumer for the parts that need to rebuild
    final inventoryProvider = Provider.of<InventoryProvider>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: _isSearching
            ? TextField(
          controller: _searchController,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Search items, rooms...',
            border: InputBorder.none,
            hintStyle: TextStyle(color: Colors.blueGrey),
          ),
          style: const TextStyle(fontSize: 18),
          onChanged: (val) => inventoryProvider.setSearchQuery(val),
        )
            : const Text('My Inventory'),
        actions: [
          // 1. Search Toggle Button
          IconButton(
            icon: Icon(_isSearching ? Icons.close : Icons.search),
            onPressed: () {
              setState(() {
                _isSearching = !_isSearching;
                if (!_isSearching) {
                  _searchController.clear();
                  inventoryProvider.setSearchQuery('');
                }
              });
            },
          ),
          // 2. Export/Backup Button (Hidden during search for space)
          if (!_isSearching)
            IconButton(
              icon: const Icon(Icons.share),
              tooltip: 'Export Backup',
              onPressed: () => _showExportMenu(context),
            ),
          // 3. Settings Button
          if (!_isSearching)
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute(builder: (context) => const SettingsScreen()),
                );
              },
            ),
          // 4. Total Value Pill
          Padding(
            padding: const EdgeInsets.only(right: 16.0, left: 8.0),
            child: Center(
              child: Consumer<InventoryProvider>(
                builder: (context, provider, child) {
                  final format = NumberFormat.simpleCurrency();
                  return Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: Colors.green[100],
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Text(
                      format.format(provider.totalValue),
                      style: TextStyle(
                        fontWeight: FontWeight.bold,
                        fontSize: 14,
                        color: Colors.green[800],
                      ),
                    ),
                  );
                },
              ),
            ),
          )
        ],
      ),
      body: Consumer<InventoryProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          final displayItems = provider.filteredItems;

          if (displayItems.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    _isSearching ? Icons.search_off : Icons.inventory_2_outlined,
                    size: 80,
                    color: Colors.grey[300],
                  ),
                  const SizedBox(height: 16),
                  Text(
                    _isSearching
                        ? 'No items match your search.'
                        : 'Your inventory is empty.\nTap the button below to add an item.',
                    textAlign: TextAlign.center,
                    style: const TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: displayItems.length,
            padding: const EdgeInsets.all(8),
            itemBuilder: (context, index) {
              final item = displayItems[index];
              return Card(
                elevation: 2,
                margin: const EdgeInsets.symmetric(vertical: 6, horizontal: 4),
                child: ListTile(
                  contentPadding: const EdgeInsets.all(10),
                  leading: ClipRRect(
                    borderRadius: BorderRadius.circular(8),
                    child: SizedBox(
                      width: 60,
                      height: 60,
                      child: item.imagePaths.isNotEmpty
                          ? Image.file(
                        File(item.imagePaths[0]),
                        fit: BoxFit.cover,
                        cacheWidth: 150,
                        // FIXED: Changed 'cite' back to 'ctx'
                        errorBuilder: (ctx, err, stack) =>
                        const Icon(Icons.broken_image, color: Colors.grey),
                      )
                          : Container(
                        color: Colors.grey[200],
                        child: const Icon(Icons.image_not_supported, color: Colors.grey),
                      ),
                    ),
                  ),
                  title: Text(
                    item.name,
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  subtitle: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(item.room ?? 'Unassigned Room'),
                      Text(
                        DateFormat.yMMMd().format(item.purchaseDate),
                        style: const TextStyle(fontSize: 12),
                      ),
                    ],
                  ),
                  trailing: Text(
                    NumberFormat.simpleCurrency().format(item.value),
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 15,
                      color: Colors.blueGrey,
                    ),
                  ),
                  onTap: () {
                    Navigator.of(context).push(
                      MaterialPageRoute(
                        builder: (context) => ItemDetailScreen(item: item),
                      ),
                    );
                  },
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute(builder: (context) => const AddItemScreen()),
          );
        },
        icon: const Icon(Icons.add_a_photo),
        label: const Text("Add Item"),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\item_detail_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'add_item_screen.dart'; // Required to navigate to Edit mode

class ItemDetailScreen extends StatelessWidget {
  final Item item;
  const ItemDetailScreen({super.key, required this.item});

  @override
  Widget build(BuildContext context) {
    final currencyFormat = NumberFormat.simpleCurrency();
    final dateFormat = DateFormat.yMMMMd();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Item Details'),
        actions: [
          // --- EDIT BUTTON ---
          IconButton(
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'Edit Item',
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => AddItemScreen(itemToEdit: item),
                ),
              );
            },
          ),
          // --- DELETE BUTTON ---
          IconButton(
            icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
            onPressed: () => _confirmDelete(context),
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // --- PHOTO GALLERY CAROUSEL ---
            if (item.imagePaths.isNotEmpty)
              SizedBox(
                height: 350,
                child: PageView.builder(
                  itemCount: item.imagePaths.length,
                  itemBuilder: (ctx, i) {
                    return Container(
                      width: MediaQuery.of(context).size.width,
                      color: Colors.black,
                      child: Image.file(
                        File(item.imagePaths[i]),
                        fit: BoxFit.contain,
                      ),
                    );
                  },
                ),
              )
            else
              Container(
                height: 250,
                width: double.infinity,
                color: Colors.grey[200],
                child: const Icon(Icons.image_not_supported, size: 80, color: Colors.grey),
              ),

            if (item.imagePaths.length > 1)
              const Padding(
                padding: EdgeInsets.symmetric(vertical: 8),
                child: Center(child: Text('Swipe for more photos', style: TextStyle(color: Colors.grey, fontSize: 12))),
              ),

            Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Item Name and Price Header
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Expanded(
                        child: Text(
                          item.name,
                          style: const TextStyle(fontSize: 28, fontWeight: FontWeight.bold),
                        ),
                      ),
                      Text(
                        currencyFormat.format(item.value),
                        style: const TextStyle(fontSize: 24, color: Colors.green, fontWeight: FontWeight.bold),
                      ),
                    ],
                  ),
                  const SizedBox(height: 20),

                  // Info Cards
                  _buildSectionTitle('LOCATION & CATEGORY'),
                  Row(
                    children: [
                      _buildChip(item.room ?? 'No Room', Icons.meeting_room),
                      const SizedBox(width: 8),
                      _buildChip(item.category ?? 'No Category', Icons.category),
                    ],
                  ),

                  const SizedBox(height: 24),
                  _buildSectionTitle('PRODUCT SPECIFICATIONS'),
                  _buildDetailRow(Icons.business, 'Brand', item.brand),
                  _buildDetailRow(Icons.label_important, 'Model', item.model),
                  _buildDetailRow(Icons.qr_code, 'Serial #', item.serialNumber),
                  _buildDetailRow(Icons.calendar_today, 'Added On', dateFormat.format(item.purchaseDate)),

                  const SizedBox(height: 24),
                  _buildSectionTitle('NOTES'),
                  Container(
                    width: double.infinity,
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Colors.blueGrey[50],
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      (item.notes == null || item.notes!.isEmpty) ? 'No notes provided.' : item.notes!,
                      style: const TextStyle(fontSize: 16, height: 1.5),
                    ),
                  ),
                  const SizedBox(height: 40),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- UI HELPERS ---

  Widget _buildSectionTitle(String title) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 12),
      child: Text(
        title,
        style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Colors.blueGrey[700], letterSpacing: 1.1),
      ),
    );
  }

  Widget _buildChip(String label, IconData icon) {
    return Chip(
      avatar: Icon(icon, size: 16, color: Colors.blueGrey),
      label: Text(label),
      backgroundColor: Colors.blueGrey[50],
      side: BorderSide.none,
    );
  }

  Widget _buildDetailRow(IconData icon, String label, String? value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Icon(icon, size: 20, color: Colors.blueGrey[300]),
          const SizedBox(width: 16),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: TextStyle(color: Colors.grey[600], fontSize: 12)),
              Text(value ?? '--', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500)),
            ],
          ),
        ],
      ),
    );
  }

  void _confirmDelete(BuildContext context) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete Item?'),
        content: const Text('This will permanently remove this record and all associated photos.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(
            onPressed: () {
              Provider.of<InventoryProvider>(context, listen: false).deleteItem(item.id!);
              Navigator.pop(ctx);
              Navigator.pop(context);
            },
            child: const Text('Delete', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\settings_screen.dart
============================================================

import 'package:flutter/material.dart';
import '../providers/inventory_provider.dart';
import '../services/preferences_service.dart';
import 'package:provider/provider.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final _prefs = PreferencesService();
  List<String> _rooms = [];
  List<String> _categories = [];

  @override
  void initState() {
    super.initState();
    _refreshLists();
  }

  Future<void> _refreshLists() async {
    final r = await _prefs.getRooms();
    final c = await _prefs.getCategories();
    if (mounted) {
      setState(() {
        _rooms = r;
        _categories = c;
      });
    }
  }

  // --- LOGIC ---

  void _showAddDialog(bool isRoom) {
    final controller = TextEditingController();
    final colorScheme = Theme.of(context).colorScheme;

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(isRoom ? 'Add New Room' : 'Add New Category'),
        content: TextField(
          controller: controller,
          autofocus: true,
          textCapitalization: TextCapitalization.words,
          decoration: InputDecoration(
            hintText: isRoom ? 'e.g. Attic' : 'e.g. Collectibles',
            border: const OutlineInputBorder(),
          ),
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          ElevatedButton(
            onPressed: () async {
              if (controller.text.trim().isNotEmpty) {
                final text = controller.text.trim();
                isRoom ? await _prefs.saveRooms([..._rooms, text]) : await _prefs.saveCategories([..._categories, text]);
                _refreshLists();
                if (mounted) Navigator.pop(ctx);
              }
            },
            child: const Text('Add'),
          ),
        ],
      ),
    );
  }

  void _handleDelete(bool isRoom, String itemName) async {
    final inventory = Provider.of<InventoryProvider>(context, listen: false);

    // Using the count logic we discussed
    int count = isRoom
        ? inventory.items.where((i) => i.room == itemName).length
        : inventory.items.where((i) => i.category == itemName).length;

    if (count > 0) {
      _showDeleteWarning(itemName, count, isRoom);
    } else {
      _performDelete(isRoom, itemName);
    }
  }

  Future<void> _performDelete(bool isRoom, String itemName) async {
    if (isRoom) {
      _rooms.remove(itemName);
      await _prefs.saveRooms(_rooms);
    } else {
      _categories.remove(itemName);
      await _prefs.saveCategories(_categories);
    }
    _refreshLists();
  }

  // --- UI COMPONENTS ---

  void _showDeleteWarning(String name, int count, bool isRoom) {
    final colorScheme = Theme.of(context).colorScheme;

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.warning_amber_rounded, color: colorScheme.error),
            const SizedBox(width: 10),
            const Text('Items in Use'),
          ],
        ),
        content: Text(
            'There are $count items currently assigned to the ${isRoom ? 'Room' : 'Category'} "$name".\n\n'
                'If you delete this, those items will keep the label "$name", but it will no longer appear in your selection lists. Proceed?'
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx),
            child: const Text('CANCEL'),
          ),
          TextButton(
            onPressed: () {
              _performDelete(isRoom, name);
              Navigator.pop(ctx);
            },
            child: Text('DELETE ANYWAY', style: TextStyle(color: colorScheme.error)),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: const Text('Manage Lists'),
          bottom: const TabBar(
            tabs: [
              Tab(icon: Icon(Icons.meeting_room), text: 'Rooms'),
              Tab(icon: Icon(Icons.style), text: 'Categories'),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            _buildList(true, _rooms),
            _buildList(false, _categories),
          ],
        ),
        floatingActionButton: Builder(
          builder: (context) => FloatingActionButton.extended(
            onPressed: () {
              final tabIndex = DefaultTabController.of(context).index;
              _showAddDialog(tabIndex == 0);
            },
            label: const Text('Add New'),
            icon: const Icon(Icons.add),
          ),
        ),
      ),
    );
  }

  Widget _buildList(bool isRoom, List<String> items) {
    if (items.isEmpty) {
      return Center(
        child: Text(
          'No ${isRoom ? 'rooms' : 'categories'} added yet.',
          style: const TextStyle(color: Colors.grey),
        ),
      );
    }

    return ListView.separated(
      padding: const EdgeInsets.all(8),
      itemCount: items.length,
      separatorBuilder: (context, index) => const Divider(height: 1),
      itemBuilder: (ctx, i) {
        final itemName = items[i];
        return ListTile(
          title: Text(itemName),
          leading: Icon(isRoom ? Icons.door_front_door_outlined : Icons.label_outline),
          trailing: IconButton(
            icon: const Icon(Icons.delete_outline),
            color: Theme.of(context).colorScheme.error,
            onPressed: () => _handleDelete(isRoom, itemName),
          ),
        );
      },
    );
  }
}

============================================================
PATH: .\lib\services\backup_service.dart
============================================================

import 'dart:io';
import 'dart:convert';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';

class BackupService {
  static Future<void> createAndShareBackup(BuildContext context) async {
    try {
      // 1. Fetch current items from the Provider
      final items = Provider.of<InventoryProvider>(context, listen: false).items;

      if (items.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No items to export!')),
        );
        return;
      }

      final archive = Archive();

      // 2. Create the JSON data file
      // This converts all item data (names, serials, notes) to a text file
      final List<Map<String, dynamic>> jsonData = items.map((i) => i.toMap()).toList();
      final String jsonString = jsonEncode(jsonData);
      final List<int> jsonBytes = utf8.encode(jsonString);
      archive.addFile(ArchiveFile('inventory_data.json', jsonBytes.length, jsonBytes));

      // 3. Add ALL images to the ZIP
      // We loop through every item, then every path in that item's imagePaths list
      for (var item in items) {
        for (var imagePath in item.imagePaths) {
          final imageFile = File(imagePath);
          if (await imageFile.exists()) {
            final fileName = path.basename(imagePath);
            final bytes = await imageFile.readAsBytes();
            archive.addFile(ArchiveFile('images/$fileName', bytes.length, bytes));
          }
        }
      }

      // 4. Save the ZIP file to temporary storage
      final zipEncoder = ZipEncoder();
      final List<int>? zipBytes = zipEncoder.encode(archive);

      if (zipBytes == null) return;

      final tempDir = await getTemporaryDirectory();
      final zipFile = File('${tempDir.path}/Home_Inventory_Backup.zip');
      await zipFile.writeAsBytes(zipBytes);

      // 5. Trigger the Share Sheet
      final xFile = XFile(zipFile.path);
      await Share.shareXFiles(
        [xFile],
        text: 'My Home Inventory Backup (Insurance Data)',
      );

    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Backup failed: $e')),
      );
    }
  }
}

============================================================
PATH: .\lib\services\pdf_service.dart
============================================================

import 'dart:io';
import 'package:flutter/services.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../models/item.dart';
import 'package:intl/intl.dart';

class PdfService {
  static Future<void> generateInventoryReport(List<Item> items) async {
    final pdf = pw.Document();
    final currencyFormat = NumberFormat.simpleCurrency();
    final dateFormat = DateFormat.yMMMd();

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.all(32),
        build: (context) => [
          _buildHeader(items.length, items.fold(0.0, (sum, item) => sum + item.value)),
          pw.SizedBox(height: 20),

          // Generate a row for every item
          ...items.map((item) => _buildItemRow(item, currencyFormat, dateFormat)).toList(),
        ],
      ),
    );

    await Printing.sharePdf(bytes: await pdf.save(), filename: 'inventory_report.pdf');
  }

  static pw.Widget _buildHeader(int count, double total) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Text("Home Inventory Report", style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold)),
        pw.Text("Generated on: ${DateFormat.yMMMd().format(DateTime.now())}"),
        pw.Divider(),
        pw.Row(
          mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
          children: [
            pw.Text("Total Items: $count"),
            pw.Text("Total Value: ${NumberFormat.simpleCurrency().format(total)}",
                style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
          ],
        ),
      ],
    );
  }

  static pw.Widget _buildItemRow(Item item, NumberFormat currency, DateFormat date) {
    // Point 8 & 11: Defensive Image Loading
    pw.MemoryImage? imageProvider;

    if (item.imagePaths.isNotEmpty) {
      try {
        final file = File(item.imagePaths[0]);
        // Point 8: Verify existence so readAsBytesSync doesn't throw a FileSystemException
        if (file.existsSync()) {
          // Point 11: In a production app, we would ideally use a resized
          // thumbnail here to save RAM, but checking existence is the first priority.
          imageProvider = pw.MemoryImage(file.readAsBytesSync());
        }
      } catch (e) {
        // If something goes wrong with a specific image, we log it and
        // let the PDF continue generating without that image.
        print("Error loading image for PDF: $e");
      }
    }

    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 10),
      padding: const pw.EdgeInsets.all(8),
      decoration: pw.BoxDecoration(
        border: pw.Border.all(color: PdfColors.grey300),
        borderRadius: pw.BorderRadius.circular(4),
      ),
      child: pw.Row(
        crossAxisAlignment: pw.CrossAxisAlignment.start,
        children: [
          // Image Thumbnail with fixed sizing to prevent layout shifts
          pw.Container(
            width: 80,
            height: 80,
            color: PdfColors.grey100, // Light background for missing images
            child: imageProvider != null
                ? pw.Image(imageProvider, fit: pw.BoxFit.cover)
                : pw.Center(
              child: pw.Text(
                item.imagePaths.isEmpty ? "No Photo" : "Photo Error",
                style: const pw.TextStyle(fontSize: 7),
                textAlign: pw.TextAlign.center,
              ),
            ),
          ),
          pw.SizedBox(width: 15),
          // Details
          pw.Expanded(
            child: pw.Column(
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Text(item.name, style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 13)),
                pw.SizedBox(height: 2),
                pw.Text("Room: ${item.room ?? 'N/A'} | Category: ${item.category ?? 'N/A'}", style: const pw.TextStyle(fontSize: 9)),
                if (item.serialNumber != null && item.serialNumber!.isNotEmpty)
                  pw.Text("Serial: ${item.serialNumber}", style: const pw.TextStyle(fontSize: 9)),
                pw.Text("Purchased: ${date.format(item.purchaseDate)}", style: const pw.TextStyle(fontSize: 9)),
                if (item.notes != null && item.notes!.isNotEmpty)
                  pw.Padding(
                    padding: const pw.EdgeInsets.only(top: 4),
                    child: pw.Text("Notes: ${item.notes}", style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey700)),
                  ),
              ],
            ),
          ),
          pw.Text(currency.format(item.value), style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\services\preferences_service.dart
============================================================

import 'package:shared_preferences/shared_preferences.dart';

class PreferencesService {
  // We'll keep your existing keys so user data isn't lost
  static const _keyRooms = 'custom_rooms';
  static const _keyCategories = 'custom_categories';

  static const List<String> _defaultRooms = ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
  static const List<String> _defaultCategories = ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];

  // --- GETTERS ---
  Future<List<String>> getRooms() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_keyRooms) ?? List.from(_defaultRooms);
  }

  Future<List<String>> getCategories() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_keyCategories) ?? List.from(_defaultCategories);
  }

  // --- SETTERS (The "save" methods the UI expects) ---

  Future<void> saveRooms(List<String> rooms) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_keyRooms, rooms);
  }

  Future<void> saveCategories(List<String> categories) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_keyCategories, categories);
  }
}

============================================================
PATH: .\lib\services\zip_service.dart
============================================================

import 'dart:io';
import 'package:archive/archive_io.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'dart:developer' as dev;

class ZipService {
  // Point 14: Clear naming to avoid package collisions
  static Future<String> _getDatabasePath() async {
    final dbFolder = await getDatabasesPath();
    return p.join(dbFolder, 'inventory.db');
  }

  /// The main method used by your UI/Provider
  static Future<File?> createFullBackup(List<String> allImagePaths) async {
    try {
      final encoder = ZipFileEncoder();
      final tempDir = await getTemporaryDirectory();
      final zipPath = p.join(tempDir.path, 'inventory_backup.zip');

      encoder.create(zipPath);

      // 1. Add the Database File
      final dbFilePath = await _getDatabasePath();
      final dbFile = File(dbFilePath);

      if (dbFile.existsSync()) {
        encoder.addFile(dbFile);
      } else {
        dev.log("Backup Error: Database file not found at $dbFilePath");
      }

      // 2. Add Images (Point 8 & 11 logic)
      for (String path in allImagePaths) {
        if (path.isEmpty) continue;

        final imgFile = File(path);

        // Point 8: Verify file exists before archiving
        if (imgFile.existsSync()) {
          encoder.addFile(imgFile);
        } else {
          // Point 11: Log missing files instead of crashing the process
          dev.log("Backup Warning: Skipping missing image at $path");
        }
      }

      encoder.close();
      return File(zipPath);
    } catch (e) {
      dev.log("Critical Backup Failure: $e");
      return null;
    }
  }
}

============================================================
PATH: .\lib\widgets\barcode_scanner.dart
============================================================

import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';

class BarcodeScannerWidget extends StatefulWidget {
  const BarcodeScannerWidget({super.key});

  @override
  State<BarcodeScannerWidget> createState() => _BarcodeScannerWidgetState();
}

class _BarcodeScannerWidgetState extends State<BarcodeScannerWidget> {
  // MobileScannerController allows us to control the flash or switch cameras
  MobileScannerController cameraController = MobileScannerController();

  @override
  void dispose() {
    cameraController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan Serial Number'),
        actions: [
          // Flashlight toggle
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: cameraController,
              builder: (context, state, child) {
                // We handle all three states: off, on, and auto
                switch (state.torchState) {
                  case TorchState.off:
                    return const Icon(Icons.flash_off, color: Colors.grey);
                  case TorchState.on:
                    return const Icon(Icons.flash_on, color: Colors.yellow);
                  case TorchState.auto:
                    return const Icon(Icons.flash_auto, color: Colors.blueAccent);
                  case TorchState.unavailable:
                    // TODO: Handle this case.
                    throw UnimplementedError();
                }
              },
            ),
            onPressed: () => cameraController.toggleTorch(),
          ),
        ],
      ),
      body: MobileScanner(
        controller: cameraController,
        onDetect: (BarcodeCapture capture) { // Explicitly define BarcodeCapture
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty) {
            final String code = barcodes.first.rawValue ?? "Unknown";
            Navigator.pop(context, code);
          }
        },
      ),
    );
  }
}

============================================================
PATH: .\test\widget_test.dart
============================================================

