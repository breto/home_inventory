FLUTTER PROJECT CODEBASE BUNDLE
Generated for Gemini Analysis


============================================================
PATH: .\analysis_options.yaml
============================================================

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


============================================================
PATH: .\devtools_options.yaml
============================================================

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:


============================================================
PATH: .\pubspec.yaml
============================================================

name: home_inventory
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.8

# Section 1: Packages your app NEEDS to run
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.1.1
  sqflite: ^2.3.0
  path: ^1.8.3
  image_picker: ^1.0.4
  path_provider: ^2.1.1
  intl: ^0.20.2
  archive: ^4.0.7
  share_plus: ^12.0.1
  shared_preferences: ^2.5.4
  pdf: ^3.10.7
  printing: ^5.11.1
  flutter_image_compress: ^2.3.0
  mobile_scanner: ^5.2.0
  file_picker: ^8.0.0
  csv: ^5.0.2

# Section 2: Tools for you (the developer) only
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true

============================================================
PATH: .\lib\main.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'providers/inventory_provider.dart';
import 'screens/home_screen.dart';

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return ChangeNotifierProvider(
      // Change fetchItems() to initializeData()
      create: (context) => InventoryProvider()..initializeData(),
      child: MaterialApp(
        title: 'Home Inventory',
        theme: ThemeData(
          primarySwatch: Colors.blue,
          useMaterial3: true,
        ),
        home: const HomeScreen(),
      ),
    );
  }
}

============================================================
PATH: .\lib\data\database_helper.dart
============================================================

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/item.dart';
import 'dart:developer' as dev;

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  // Incremented version to 5 to trigger migration
  static const String _dbName = 'inventory.db';
  static const int _dbVersion = 5;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB(_dbName);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);

    return await openDatabase(
      path,
      version: _dbVersion,
      onCreate: _createDB,
      onUpgrade: _onUpgrade,
    );
  }

  Future _createDB(Database db, int version) async {
    // Items Table with all current fields
    await db.execute('''
      CREATE TABLE items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        value REAL NOT NULL,
        purchaseDate TEXT NOT NULL,
        warrantyExpiry TEXT,
        imagePaths TEXT NOT NULL,
        receiptIndices TEXT,
        room TEXT,
        category TEXT,
        serialNumber TEXT,
        brand TEXT,
        model TEXT,
        notes TEXT
      )
    ''');

    await db.execute('CREATE TABLE rooms (name TEXT PRIMARY KEY)');
    await db.execute('CREATE TABLE categories (name TEXT PRIMARY KEY)');

    // Seed Data
    final rooms = ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
    for (var r in rooms) await db.insert('rooms', {'name': r});

    final cats = ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];
    for (var c in cats) await db.insert('categories', {'name': c});
  }

  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    dev.log("Upgrading database from $oldVersion to $newVersion");

    if (oldVersion < 5) {
      // Add the new columns for Receipt tracking and Warranty
      // We use 'ALTER TABLE' so existing user data stays intact
      try {
        await db.execute('ALTER TABLE items ADD COLUMN warrantyExpiry TEXT');
        await db.execute('ALTER TABLE items ADD COLUMN receiptIndices TEXT');
      } catch (e) {
        dev.log("Migration Note: Columns might already exist. $e");
      }
    }
  }

  // --- CRUD OPERATIONS ---

  Future<int> create(Item item) async {
    final db = await instance.database;
    return await db.insert('items', item.toMap());
  }

  Future<List<Item>> readAllItems() async {
    final db = await instance.database;
    final result = await db.query('items', orderBy: 'name ASC');
    return result.map((json) => Item.fromMap(json)).toList();
  }

  Future<int> update(Item item) async {
    final db = await instance.database;
    return db.update(
        'items',
        item.toMap(),
        where: 'id = ?',
        whereArgs: [item.id]
    );
  }

  Future<int> delete(int id) async {
    final db = await instance.database;
    return await db.delete('items', where: 'id = ?', whereArgs: [id]);
  }

  // --- LIST HELPERS ---

  Future<List<String>> getRooms() async {
    final db = await database;
    final res = await db.query('rooms', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveRooms(List<String> rooms) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('rooms');
      for (var r in rooms) await txn.insert('rooms', {'name': r});
    });
  }

  Future<List<String>> getCategories() async {
    final db = await database;
    final res = await db.query('categories', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveCategories(List<String> categories) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('categories');
      for (var c in categories) await txn.insert('categories', {'name': c});
    });
  }
}

============================================================
PATH: .\lib\models\item.dart
============================================================

import 'dart:convert';

class Item {
  final int? id;
  final String name;
  final List<String> imagePaths;
  final double value;
  final DateTime purchaseDate;
  final DateTime? warrantyExpiry;
  final String? serialNumber;
  final String? brand;
  final String? model;
  final String? notes;
  final String? room;
  final String? category;
  final List<int> receiptIndices; // Indices of images that are receipts

  Item({
    this.id,
    required this.name,
    required this.imagePaths,
    required this.value,
    required this.purchaseDate,
    this.warrantyExpiry,
    this.serialNumber,
    this.brand,
    this.model,
    this.notes,
    this.room,
    this.category,
    this.receiptIndices = const [],
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'imagePaths': jsonEncode(imagePaths),
      'value': value,
      'purchaseDate': purchaseDate.toIso8601String(),
      'warrantyExpiry': warrantyExpiry?.toIso8601String(),
      'serialNumber': serialNumber,
      'brand': brand,
      'model': model,
      'notes': notes,
      'room': room,
      'category': category,
      'receiptIndices': jsonEncode(receiptIndices),
    };
  }

  factory Item.fromMap(Map<String, dynamic> map) {
    return Item(
      id: map['id'],
      name: map['name'],
      imagePaths: List<String>.from(jsonDecode(map['imagePaths'])),
      value: map['value'],
      purchaseDate: DateTime.parse(map['purchaseDate']),
      warrantyExpiry: map['warrantyExpiry'] != null ? DateTime.parse(map['warrantyExpiry']) : null,
      serialNumber: map['serialNumber'],
      brand: map['brand'],
      model: map['model'],
      notes: map['notes'],
      room: map['room'],
      category: map['category'],
      receiptIndices: map['receiptIndices'] != null
          ? List<int>.from(jsonDecode(map['receiptIndices']))
          : [],
    );
  }
}

============================================================
PATH: .\lib\providers\inventory_provider.dart
============================================================

import 'package:flutter/material.dart';
import '../models/item.dart';
import '../data/database_helper.dart';

class InventoryProvider with ChangeNotifier {
  List<Item> _items = [];
  List<String> _rooms = [];
  List<String> _categories = [];
  bool _isLoading = false;
  String _searchQuery = '';

  List<Item> get items => _items;
  List<String> get rooms => _rooms;
  List<String> get categories => _categories;
  bool get isLoading => _isLoading;
  String get searchQuery => _searchQuery;

  // --- INITIALIZATION ---

  Future<void> initializeData() async {
    _isLoading = true;
    notifyListeners();

    try {
      _items = await DatabaseHelper.instance.readAllItems();
      _rooms = await DatabaseHelper.instance.getRooms();
      _categories = await DatabaseHelper.instance.getCategories();
    } catch (e) {
      debugPrint('Error initializing data: $e');
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  Future<void> refreshAfterImport() async {
    await initializeData();
  }

  // --- SEARCH ---

  void setSearchQuery(String query) {
    _searchQuery = query;
    notifyListeners();
  }

  List<Item> get filteredItems {
    if (_searchQuery.isEmpty) return _items;
    return _items.where((item) {
      final searchLower = _searchQuery.toLowerCase();
      return item.name.toLowerCase().contains(searchLower) ||
          (item.room ?? '').toLowerCase().contains(searchLower) ||
          (item.category ?? '').toLowerCase().contains(searchLower);
    }).toList();
  }

  // --- ACTIONS ---

  Future<void> addItem(Item item) async {
    await DatabaseHelper.instance.create(item);
    _items = await DatabaseHelper.instance.readAllItems();
    notifyListeners();
  }

  Future<void> updateItem(Item item) async {
    await DatabaseHelper.instance.update(item);
    _items = await DatabaseHelper.instance.readAllItems();
    notifyListeners();
  }

  Future<void> deleteItem(int id) async {
    await DatabaseHelper.instance.delete(id);
    _items = await DatabaseHelper.instance.readAllItems();
    notifyListeners();
  }

  Future<void> addRoom(String name) async {
    if (!_rooms.contains(name)) {
      _rooms.add(name);
      _rooms.sort();
      await DatabaseHelper.instance.saveRooms(_rooms);
      notifyListeners();
    }
  }

  Future<void> removeRoom(String name) async {
    _rooms.remove(name);
    await DatabaseHelper.instance.saveRooms(_rooms);
    notifyListeners();
  }

  Future<void> addCategory(String name) async {
    if (!_categories.contains(name)) {
      _categories.add(name);
      _categories.sort();
      await DatabaseHelper.instance.saveCategories(_categories);
      notifyListeners();
    }
  }

  Future<void> removeCategory(String name) async {
    _categories.remove(name);
    await DatabaseHelper.instance.saveCategories(_categories);
    notifyListeners();
  }

  // --- HELPER COUNTS ---

  int getItemsCountInRoom(String roomName) => _items.where((i) => i.room == roomName).length;
  int getItemsCountInCategory(String catName) => _items.where((i) => i.category == catName).length;
  double get totalValue => _items.fold(0.0, (sum, item) => sum + item.value);
}

============================================================
PATH: .\lib\repositories\list_repository.dart
============================================================

import '../data/database_helper.dart';

class ListRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;

  // Rooms logic
  Future<List<String>> fetchRooms() async {
    final rooms = await _db.getRooms();
    // Professional touch: If DB is empty, provide defaults but don't save them yet
    if (rooms.isEmpty) {
      return ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
    }
    return rooms;
  }

  Future<void> updateRooms(List<String> rooms) => _db.saveRooms(rooms);

  // Categories logic
  Future<List<String>> fetchCategories() async {
    final categories = await _db.getCategories();
    if (categories.isEmpty) {
      return ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];
    }
    return categories;
  }

  Future<void> updateCategories(List<String> categories) => _db.saveCategories(categories);
}

============================================================
PATH: .\lib\screens\add_item_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'package:flutter_image_compress/flutter_image_compress.dart';
import '../widgets/barcode_scanner.dart';

class AddItemScreen extends StatefulWidget {
  final Item? itemToEdit;
  const AddItemScreen({super.key, this.itemToEdit});

  @override
  State<AddItemScreen> createState() => _AddItemScreenState();
}

class _AddItemScreenState extends State<AddItemScreen> {
  final _formKey = GlobalKey<FormState>();

  final _nameController = TextEditingController();
  final _valueController = TextEditingController();
  final _serialController = TextEditingController();
  final _brandController = TextEditingController();
  final _modelController = TextEditingController();
  final _notesController = TextEditingController();

  List<File> _imageFiles = [];
  List<int> _receiptIndices = [];
  String? _selectedRoom;
  String? _selectedCategory;
  DateTime _purchaseDate = DateTime.now();
  DateTime? _warrantyExpiry;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    if (widget.itemToEdit != null) {
      final item = widget.itemToEdit!;
      _nameController.text = item.name;
      _valueController.text = item.value == 0.0 ? '' : item.value.toString();
      _serialController.text = item.serialNumber ?? '';
      _brandController.text = item.brand ?? '';
      _modelController.text = item.model ?? '';
      _notesController.text = item.notes ?? '';
      _selectedRoom = item.room;
      _selectedCategory = item.category;
      _purchaseDate = item.purchaseDate;
      _warrantyExpiry = item.warrantyExpiry;
      _receiptIndices = List.from(item.receiptIndices);
      _imageFiles = item.imagePaths.map((path) => File(path)).toList();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _valueController.dispose();
    _serialController.dispose();
    _brandController.dispose();
    _modelController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _pickImage(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: source, imageQuality: 75);
    if (pickedFile != null) {
      setState(() => _imageFiles.add(File(pickedFile.path)));
    }
  }

  Future<void> _selectDate(BuildContext context, bool isPurchaseDate) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: isPurchaseDate ? _purchaseDate : (_warrantyExpiry ?? DateTime.now()),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) {
      setState(() {
        if (isPurchaseDate) _purchaseDate = picked;
        else _warrantyExpiry = picked;
      });
    }
  }

  Future<void> _saveItem() async {
    if (_isSaving || !_formKey.currentState!.validate()) return;
    if (_imageFiles.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('At least one photo is required.')));
      return;
    }

    setState(() => _isSaving = true);
    try {
      final appDir = await getApplicationDocumentsDirectory();
      List<String> savedPaths = [];

      for (var file in _imageFiles) {
        if (file.path.contains(appDir.path)) {
          savedPaths.add(file.path);
        } else {
          final fileName = 'img_${DateTime.now().millisecondsSinceEpoch}_${path.basename(file.path)}';
          final targetPath = '${appDir.path}/$fileName';
          var result = await FlutterImageCompress.compressAndGetFile(
            file.absolute.path, targetPath, quality: 70, minWidth: 1024, minHeight: 1024,
          );
          savedPaths.add(result?.path ?? (await file.copy(targetPath)).path);
        }
      }

      final newItem = Item(
        id: widget.itemToEdit?.id,
        name: _nameController.text.trim(),
        imagePaths: savedPaths,
        value: double.tryParse(_valueController.text.replaceAll(',', '')) ?? 0.0,
        purchaseDate: _purchaseDate,
        warrantyExpiry: _warrantyExpiry,
        serialNumber: _serialController.text.isEmpty ? null : _serialController.text,
        brand: _brandController.text.isEmpty ? null : _brandController.text,
        model: _modelController.text.isEmpty ? null : _modelController.text,
        notes: _notesController.text.isEmpty ? null : _notesController.text,
        room: (_selectedRoom == "None" || _selectedRoom == null) ? null : _selectedRoom,
        category: (_selectedCategory == "None" || _selectedCategory == null) ? null : _selectedCategory,
        receiptIndices: _receiptIndices,
      );

      final provider = Provider.of<InventoryProvider>(context, listen: false);
      widget.itemToEdit == null ? await provider.addItem(newItem) : await provider.updateItem(newItem);
      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final provider = context.watch<InventoryProvider>();
    final roomOptions = ["None", ...provider.rooms];
    final categoryOptions = ["None", ...provider.categories];

    return Scaffold(
      appBar: AppBar(title: Text(widget.itemToEdit == null ? 'Add Item' : 'Edit Item')),
      body: _isSaving ? const Center(child: CircularProgressIndicator()) : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildPhotoHeader(),
              _buildPhotoGallery(theme),
              const SizedBox(height: 24),
              _buildTextField(_nameController, 'Item Name', Icons.inventory_2, isRequired: true),
              _buildTextField(_valueController, 'Estimated Value (\$)', Icons.monetization_on, isNumber: true),

              Row(
                children: [
                  Expanded(child: _buildDatePicker('Purchase Date', _purchaseDate, () => _selectDate(context, true))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDatePicker('Warranty Until', _warrantyExpiry, () => _selectDate(context, false), isOptional: true)),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildDropdown('Room', _selectedRoom, roomOptions, (val) => setState(() => _selectedRoom = val))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDropdown('Category', _selectedCategory, categoryOptions, (val) => setState(() => _selectedCategory = val))),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildTextField(_brandController, 'Brand', Icons.factory)),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_modelController, 'Model #', Icons.label_important)),
                ],
              ),
              _buildScanTextField(_serialController, 'Serial Number / UPC', Icons.qr_code_scanner),
              _buildTextField(_notesController, 'Notes / Description', Icons.description, maxLines: 3),
              const SizedBox(height: 32),
              _buildSaveButton(theme),
            ],
          ),
        ),
      ),
    );
  }

  // --- UI COMPONENTS ---

  Widget _buildPhotoHeader() {
    return const Padding(
      padding: EdgeInsets.only(bottom: 8),
      child: Text("Photos & Receipts *", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
    );
  }

  Widget _buildPhotoGallery(ThemeData theme) {
    return SizedBox(
      height: 140,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: _imageFiles.length + 1,
        itemBuilder: (ctx, i) {
          if (i == _imageFiles.length) return _buildAddPhotoButton(theme);
          bool isReceipt = _receiptIndices.contains(i);
          return _buildPhotoPreview(i, isReceipt);
        },
      ),
    );
  }

  Widget _buildPhotoPreview(int index, bool isReceipt) {
    return Stack(
      children: [
        Container(
          margin: const EdgeInsets.only(right: 12, top: 10),
          width: 110,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            image: DecorationImage(image: FileImage(_imageFiles[index]), fit: BoxFit.cover),
            border: Border.all(color: isReceipt ? Colors.green : Colors.grey.shade300, width: 2),
          ),
        ),
        // Delete Button
        Positioned(right: 0, top: 0, child: GestureDetector(
          onTap: () => setState(() {
            _imageFiles.removeAt(index);
            _receiptIndices.remove(index);
            _receiptIndices = _receiptIndices.map((e) => e > index ? e - 1 : e).toList();
          }),
          child: const CircleAvatar(radius: 12, backgroundColor: Colors.red, child: Icon(Icons.close, size: 16, color: Colors.white)),
        )),
        // Receipt Toggle
        Positioned(left: 5, bottom: 5, child: GestureDetector(
          onTap: () => setState(() => _receiptIndices.contains(index) ? _receiptIndices.remove(index) : _receiptIndices.add(index)),
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
            decoration: BoxDecoration(color: isReceipt ? Colors.green : Colors.black54, borderRadius: BorderRadius.circular(8)),
            child: Row(children: [
              Icon(Icons.receipt_long, size: 12, color: Colors.white),
              const SizedBox(width: 4),
              Text(isReceipt ? "Receipt" : "Tag Receipt", style: const TextStyle(color: Colors.white, fontSize: 10)),
            ]),
          ),
        )),
      ],
    );
  }

  Widget _buildDatePicker(String label, DateTime? date, VoidCallback onTap, {bool isOptional = false}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: InkWell(
        onTap: onTap,
        child: InputDecorator(
          decoration: InputDecoration(labelText: isOptional ? '$label (Optional)' : label, border: const OutlineInputBorder()),
          child: Text(date == null ? 'Select Date' : DateFormat('MMM d, yyyy').format(date)),
        ),
      ),
    );
  }

  // (Remaining helpers: _buildTextField, _buildDropdown, _buildScanTextField, _buildAddPhotoButton, _showPickerOptions are kept from previous versions)
  // [Truncated for brevity, but include identical logic to the previous full file gen]

  Widget _buildSaveButton(ThemeData theme) {
    return ElevatedButton.icon(
      onPressed: _saveItem,
      icon: const Icon(Icons.check_circle),
      label: const Text('SAVE TO INVENTORY', style: TextStyle(fontWeight: FontWeight.bold)),
      style: ElevatedButton.styleFrom(
        minimumSize: const Size(double.infinity, 60),
        backgroundColor: theme.colorScheme.primary,
        foregroundColor: theme.colorScheme.onPrimary,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      ),
    );
  }

  Widget _buildTextField(TextEditingController controller, String label, IconData icon, {bool isNumber = false, int maxLines = 1, bool isRequired = false}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        maxLines: maxLines,
        keyboardType: isNumber ? const TextInputType.numberWithOptions(decimal: true) : TextInputType.text,
        decoration: InputDecoration(
          labelText: isRequired ? label : '$label (Optional)',
          prefixIcon: Icon(icon),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
        ),
        validator: (v) => (isRequired && (v == null || v.trim().isEmpty)) ? 'Please enter $label' : null,
      ),
    );
  }

  Widget _buildDropdown(String label, String? value, List<String> items, Function(String?) onChanged) {
    final effectiveValue = items.contains(value) ? value : "None";
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: DropdownButtonFormField<String>(
        value: effectiveValue,
        decoration: InputDecoration(labelText: '$label (Optional)', border: OutlineInputBorder(borderRadius: BorderRadius.circular(8))),
        items: items.map((s) => DropdownMenuItem(value: s, child: Text(s))).toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildScanTextField(TextEditingController controller, String label, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: '$label (Optional)',
          prefixIcon: Icon(icon),
          suffixIcon: IconButton(
            icon: Icon(Icons.camera_alt, color: Theme.of(context).colorScheme.primary),
            onPressed: () async {
              final String? scannedCode = await Navigator.push(context, MaterialPageRoute(builder: (context) => const BarcodeScannerWidget()));
              if (scannedCode != null && mounted) setState(() => controller.text = scannedCode);
            },
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
        ),
      ),
    );
  }

  Widget _buildAddPhotoButton(ThemeData theme) {
    return GestureDetector(
      onTap: () => _showPickerOptions(),
      child: Container(
        margin: const EdgeInsets.only(top: 10),
        width: 100,
        decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant, borderRadius: BorderRadius.circular(12), border: Border.all(color: theme.colorScheme.outlineVariant)),
        child: Column(mainAxisAlignment: MainAxisAlignment.center, children: [
          Icon(Icons.add_a_photo, color: theme.colorScheme.primary),
          const SizedBox(height: 4),
          Text("Add Photo", style: TextStyle(fontSize: 12, color: theme.colorScheme.primary)),
        ]),
      ),
    );
  }

  void _showPickerOptions() {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) => Padding(
        padding: const EdgeInsets.symmetric(vertical: 20),
        child: Column(mainAxisSize: MainAxisSize.min, children: [
          ListTile(leading: const Icon(Icons.camera_alt), title: const Text('Take Photo'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.camera); }),
          ListTile(leading: const Icon(Icons.photo_library), title: const Text('From Gallery'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.gallery); }),
        ]),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\home_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:home_inventory/screens/add_item_screen.dart';
import 'package:home_inventory/screens/item_detail_screen.dart';
import 'package:home_inventory/screens/settings_screen.dart';
import 'package:home_inventory/services/pdf_service.dart';
import 'package:home_inventory/services/zip_service.dart';
import 'package:home_inventory/services/export_service.dart'; // We'll create this next
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../providers/inventory_provider.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  bool _isSearching = false;
  final TextEditingController _searchController = TextEditingController();

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  void _showExportMenu(BuildContext context) {
    final provider = Provider.of<InventoryProvider>(context, listen: false);

    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text(
                "Export Inventory",
                style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 15),
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Colors.redAccent,
                  child: Icon(Icons.picture_as_pdf, color: Colors.white),
                ),
                title: const Text('Professional PDF Report'),
                subtitle: const Text('Includes photos and receipt tags'),
                onTap: () {
                  Navigator.pop(ctx);
                  PdfService.generateInventoryReport(provider.items);
                },
              ),
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Colors.green,
                  child: Icon(Icons.table_chart, color: Colors.white),
                ),
                title: const Text('CSV Spreadsheet'),
                subtitle: const Text('Best for Excel or Google Sheets'),
                onTap: () {
                  Navigator.pop(ctx);
                  ExportService.shareAsCsv(provider.items);
                },
              ),
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Colors.blue,
                  child: Icon(Icons.code, color: Colors.white),
                ),
                title: const Text('JSON Data File'),
                subtitle: const Text('Raw data backup'),
                onTap: () {
                  Navigator.pop(ctx);
                  ExportService.shareAsJson(provider.items);
                },
              ),
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Colors.orange,
                  child: Icon(Icons.folder_zip, color: Colors.white),
                ),
                title: const Text('Full ZIP Backup'),
                subtitle: const Text('Includes all original photos'),
                onTap: () {
                  Navigator.pop(ctx);
                  final allImages = provider.items.expand((item) => item.imagePaths).toList();
                  ZipService.createFullBackup(allImages);
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final inventoryProvider = Provider.of<InventoryProvider>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: _isSearching
            ? TextField(
          controller: _searchController,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Search items, rooms...',
            border: InputBorder.none,
          ),
          onChanged: (val) => inventoryProvider.setSearchQuery(val),
        )
            : const Text('My Inventory'),
        actions: [
          IconButton(
            icon: Icon(_isSearching ? Icons.close : Icons.search),
            onPressed: () {
              setState(() {
                _isSearching = !_isSearching;
                if (!_isSearching) {
                  _searchController.clear();
                  inventoryProvider.setSearchQuery('');
                }
              });
            },
          ),
          if (!_isSearching)
            IconButton(
              icon: const Icon(Icons.ios_share), // Using a standard share icon
              tooltip: 'Export',
              onPressed: () => _showExportMenu(context),
            ),
          if (!_isSearching)
            IconButton(
              icon: const Icon(Icons.settings),
              onPressed: () => Navigator.of(context).push(
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              ),
            ),
          // Total Value Pill
          Padding(
            padding: const EdgeInsets.only(right: 8.0),
            child: Center(
              child: Consumer<InventoryProvider>(
                builder: (context, provider, child) {
                  return Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      NumberFormat.simpleCurrency().format(provider.totalValue),
                      style: const TextStyle(
                        fontWeight: FontWeight.bold,
                        color: Colors.green,
                      ),
                    ),
                  );
                },
              ),
            ),
          )
        ],
      ),
      body: Consumer<InventoryProvider>(
        builder: (context, provider, child) {
          if (provider.isLoading) {
            return const Center(child: CircularProgressIndicator());
          }

          final displayItems = provider.filteredItems;

          if (displayItems.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    _isSearching ? Icons.search_off : Icons.inventory_2_outlined,
                    size: 80,
                    color: Colors.grey[300],
                  ),
                  const SizedBox(height: 16),
                  Text(
                    _isSearching ? 'No results found.' : 'Inventory is empty.',
                    style: const TextStyle(color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          return ListView.builder(
            itemCount: displayItems.length,
            padding: const EdgeInsets.symmetric(vertical: 8),
            itemBuilder: (context, index) {
              final item = displayItems[index];
              return ListTile(
                leading: ClipRRect(
                  borderRadius: BorderRadius.circular(8),
                  child: SizedBox(
                    width: 50,
                    height: 50,
                    child: item.imagePaths.isNotEmpty
                        ? Image.file(
                      File(item.imagePaths[0]),
                      fit: BoxFit.cover,
                      cacheWidth: 100,
                      errorBuilder: (ctx, err, stack) =>
                      const Icon(Icons.broken_image),
                    )
                        : Container(color: Colors.grey[200]),
                  ),
                ),
                title: Text(item.name, style: const TextStyle(fontWeight: FontWeight.w600)),
                subtitle: Text("${item.room ?? 'Unassigned'} â€¢ ${item.category ?? 'General'}"),
                trailing: Text(
                  NumberFormat.simpleCurrency().format(item.value),
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                onTap: () => Navigator.of(context).push(
                  MaterialPageRoute(
                    builder: (context) => ItemDetailScreen(itemId: item.id!),
                  ),
                ),
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => Navigator.of(context).push(
          MaterialPageRoute(builder: (context) => const AddItemScreen()),
        ),
        icon: const Icon(Icons.add),
        label: const Text("Add Item"),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\item_detail_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'add_item_screen.dart';

class ItemDetailScreen extends StatelessWidget {
  final int itemId; // Pass ID instead of full object for better state syncing
  const ItemDetailScreen({super.key, required this.itemId});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Listen to the provider. If the item is edited, this will rebuild automatically.
    final provider = context.watch<InventoryProvider>();
    final item = provider.items.firstWhere(
          (i) => i.id == itemId,
      orElse: () => Item( // Fallback if item is deleted
          name: 'Deleted',
          imagePaths: [],
          value: 0,
          purchaseDate: DateTime.now()
      ),
    );

    if (item.name == 'Deleted') {
      return const Scaffold(body: Center(child: Text("Item no longer exists.")));
    }

    return Scaffold(
      appBar: AppBar(
        title: Text(item.name),
        actions: [
          IconButton(
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'Edit Item',
            onPressed: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => AddItemScreen(itemToEdit: item)),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline),
            onPressed: () => _confirmDelete(context, provider, item),
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildImageGallery(context, item),
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildPriceAndDate(theme, item),
                  const Divider(height: 32),
                  if (item.warrantyExpiry != null) _buildWarrantyCard(theme, item),
                  _buildInfoGrid(theme, item),
                  const SizedBox(height: 20),
                  if (item.notes != null && item.notes!.isNotEmpty) _buildNotes(theme, item),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _confirmDelete(BuildContext context, InventoryProvider provider, Item item) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Delete Item?"),
        content: Text("Are you sure you want to remove ${item.name}?"),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
          TextButton(
            onPressed: () {
              provider.deleteItem(item.id!);
              Navigator.pop(ctx); // Close dialog
              Navigator.pop(context); // Return to list
            },
            child: const Text("DELETE", style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  Widget _buildImageGallery(BuildContext context, Item item) {
    if (item.imagePaths.isEmpty) return const SizedBox.shrink();
    return SizedBox(
      height: 300,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: item.imagePaths.length,
        itemBuilder: (context, index) {
          final bool isReceipt = item.receiptIndices.contains(index);
          return Stack(
            children: [
              Container(
                width: MediaQuery.of(context).size.width * 0.85,
                margin: const EdgeInsets.all(8),
                decoration: BoxDecoration(
                  borderRadius: BorderRadius.circular(15),
                  image: DecorationImage(
                    image: FileImage(File(item.imagePaths[index])),
                    fit: BoxFit.cover,
                  ),
                ),
              ),
              if (isReceipt)
                Positioned(
                  top: 20, left: 20,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(
                      color: Colors.green.withOpacity(0.9),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: const Row(
                      children: [
                        Icon(Icons.receipt_long, color: Colors.white, size: 16),
                        SizedBox(width: 4),
                        Text("RECEIPT", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 12)),
                      ],
                    ),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildWarrantyCard(ThemeData theme, Item item) {
    final now = DateTime.now();
    final isExpired = item.warrantyExpiry!.isBefore(now);
    return Container(
      margin: const EdgeInsets.only(bottom: 20),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: isExpired ? Colors.red.shade50 : Colors.blue.shade50,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: isExpired ? Colors.red.shade200 : Colors.blue.shade200),
      ),
      child: Row(
        children: [
          Icon(isExpired ? Icons.warning_amber_rounded : Icons.verified_user_outlined, color: isExpired ? Colors.red : Colors.blue),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(isExpired ? "Warranty Expired" : "Under Warranty", style: TextStyle(fontWeight: FontWeight.bold, color: isExpired ? Colors.red.shade900 : Colors.blue.shade900)),
                Text("Until ${DateFormat('MMM d, yyyy').format(item.warrantyExpiry!)}", style: const TextStyle(fontSize: 13)),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildPriceAndDate(ThemeData theme, Item item) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
          const Text("Value", style: TextStyle(fontSize: 12, color: Colors.grey)),
          Text(NumberFormat.currency(symbol: "\$").format(item.value), style: theme.textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold, color: theme.colorScheme.primary)),
        ]),
        Column(crossAxisAlignment: CrossAxisAlignment.end, children: [
          const Text("Purchased", style: TextStyle(fontSize: 12, color: Colors.grey)),
          Text(DateFormat('MMM d, yyyy').format(item.purchaseDate), style: theme.textTheme.titleMedium),
        ]),
      ],
    );
  }

  Widget _buildInfoGrid(ThemeData theme, Item item) {
    return GridView.count(
      shrinkWrap: true, physics: const NeverScrollableScrollPhysics(),
      crossAxisCount: 2, childAspectRatio: 3,
      children: [
        _buildInfoTile("Room", item.room ?? "Unassigned"),
        _buildInfoTile("Category", item.category ?? "General"),
        _buildInfoTile("Brand", item.brand ?? "N/A"),
        _buildInfoTile("Model", item.model ?? "N/A"),
      ],
    );
  }

  Widget _buildInfoTile(String label, String value) {
    return Column(crossAxisAlignment: CrossAxisAlignment.start, mainAxisAlignment: MainAxisAlignment.center, children: [
      Text(label, style: const TextStyle(fontSize: 11, color: Colors.grey)),
      Text(value, style: const TextStyle(fontWeight: FontWeight.w500, fontSize: 14), overflow: TextOverflow.ellipsis),
    ]);
  }

  Widget _buildNotes(ThemeData theme, Item item) {
    return Column(crossAxisAlignment: CrossAxisAlignment.start, children: [
      const Text("Notes", style: TextStyle(fontWeight: FontWeight.bold)),
      const SizedBox(height: 4),
      Text(item.notes!, style: const TextStyle(color: Colors.black87)),
    ]);
  }
}

============================================================
PATH: .\lib\screens\list_management_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';

class ListManagementScreen extends StatelessWidget {
  final bool isRoom;
  const ListManagementScreen({super.key, required this.isRoom});

  @override
  Widget build(BuildContext context) {
    final provider = context.watch<InventoryProvider>();
    final items = isRoom ? provider.rooms : provider.categories;

    return Scaffold(
      appBar: AppBar(title: Text(isRoom ? 'Manage Rooms' : 'Manage Categories')),
      body: items.isEmpty
          ? const Center(child: Text('No items yet.'))
          : ListView.builder(
        itemCount: items.length,
        itemBuilder: (context, index) {
          final name = items[index];
          return ListTile(
            title: Text(name),
            trailing: IconButton(
              icon: const Icon(Icons.delete_outline, color: Colors.red),
              onPressed: () => _confirmDelete(context, name, provider),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        child: const Icon(Icons.add),
        onPressed: () => _showAddDialog(context, provider),
      ),
    );
  }

  void _showAddDialog(BuildContext context, InventoryProvider provider) {
    final controller = TextEditingController();
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(isRoom ? 'Add Room' : 'Add Category'),
        content: TextField(controller: controller, autofocus: true),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('Cancel')),
          TextButton(
            onPressed: () {
              if (isRoom) provider.addRoom(controller.text);
              else provider.addCategory(controller.text);
              Navigator.pop(ctx);
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _confirmDelete(BuildContext context, String name, InventoryProvider provider) {
    int count = isRoom ? provider.getItemsCountInRoom(name) : provider.getItemsCountInCategory(name);

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Delete?'),
        content: Text('"$name" is used by $count items. Remove from selection list?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('No')),
          TextButton(
            onPressed: () {
              if (isRoom) provider.removeRoom(name);
              else provider.removeCategory(name);
              Navigator.pop(ctx);
            },
            child: const Text('Yes'),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\settings_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import '../providers/inventory_provider.dart';
import '../services/zip_service.dart';
import 'list_management_screen.dart'; // We will create this next

class SettingsScreen extends StatelessWidget {
  const SettingsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          _buildSectionHeader(context, 'Data Management'),
          _buildTile(
            context,
            icon: Icons.cloud_upload_outlined,
            color: Colors.blue,
            title: 'Export Backup',
            subtitle: 'Create a .zip file with all data and photos',
            onTap: () async {
              final provider = Provider.of<InventoryProvider>(context, listen: false);
              final allImages = provider.items.expand((item) => item.imagePaths).toList();
              File? zip = await ZipService.createFullBackup(allImages);
              if (zip != null && context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('Backup created at: ${zip.path}')),
                );
              }
            },
          ),
          _buildTile(
            context,
            icon: Icons.file_download_outlined,
            color: Colors.orange,
            title: 'Import Backup',
            subtitle: 'Restore inventory from another device',
            onTap: () => _handleImport(context),
          ),
          const Divider(),
          _buildSectionHeader(context, 'Organization'),
          _buildTile(
            context,
            icon: Icons.meeting_room_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Rooms',
            subtitle: 'Add or remove locations in your home',
            onTap: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: true)),
            ),
          ),
          _buildTile(
            context,
            icon: Icons.style_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Categories',
            subtitle: 'Define item types (Electronics, Tools, etc.)',
            onTap: () => Navigator.push(
              context,
              MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: false)),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 20, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(
          fontSize: 12,
          fontWeight: FontWeight.bold,
          color: Theme.of(context).colorScheme.secondary,
          letterSpacing: 1.1,
        ),
      ),
    );
  }

  Widget _buildTile(BuildContext context,
      {required IconData icon, required Color color, required String title, required String subtitle, required VoidCallback onTap}) {
    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withOpacity(0.1),
        child: Icon(icon, color: color),
      ),
      title: Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
      subtitle: Text(subtitle, style: const TextStyle(fontSize: 12)),
      trailing: const Icon(Icons.chevron_right, size: 20),
      onTap: onTap,
    );
  }

  Future<void> _handleImport(BuildContext context) async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(type: FileType.custom, allowedExtensions: ['zip']);
    if (result == null) return;

    final provider = Provider.of<InventoryProvider>(context, listen: false);

    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Restore Data?'),
        content: const Text('This will overwrite your current inventory. Continue?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('CANCEL')),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx);
              bool success = await ZipService.importBackup(File(result.files.single.path!));
              if (success) {
                await provider.refreshAfterImport();
              }
            },
            child: const Text('RESTORE'),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\services\backup_service.dart
============================================================

import 'dart:io';
import 'dart:convert';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';

class BackupService {
  static Future<void> createAndShareBackup(BuildContext context) async {
    try {
      // 1. Fetch current items from the Provider
      final items = Provider.of<InventoryProvider>(context, listen: false).items;

      if (items.isEmpty) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No items to export!')),
        );
        return;
      }

      final archive = Archive();

      // 2. Create the JSON data file
      // This converts all item data (names, serials, notes) to a text file
      final List<Map<String, dynamic>> jsonData = items.map((i) => i.toMap()).toList();
      final String jsonString = jsonEncode(jsonData);
      final List<int> jsonBytes = utf8.encode(jsonString);
      archive.addFile(ArchiveFile('inventory_data.json', jsonBytes.length, jsonBytes));

      // 3. Add ALL images to the ZIP
      // We loop through every item, then every path in that item's imagePaths list
      for (var item in items) {
        for (var imagePath in item.imagePaths) {
          final imageFile = File(imagePath);
          if (await imageFile.exists()) {
            final fileName = path.basename(imagePath);
            final bytes = await imageFile.readAsBytes();
            archive.addFile(ArchiveFile('images/$fileName', bytes.length, bytes));
          }
        }
      }

      // 4. Save the ZIP file to temporary storage
      final zipEncoder = ZipEncoder();
      final List<int>? zipBytes = zipEncoder.encode(archive);

      if (zipBytes == null) return;

      final tempDir = await getTemporaryDirectory();
      final zipFile = File('${tempDir.path}/Home_Inventory_Backup.zip');
      await zipFile.writeAsBytes(zipBytes);

      // 5. Trigger the Share Sheet
      final xFile = XFile(zipFile.path);
      await Share.shareXFiles(
        [xFile],
        text: 'My Home Inventory Backup (Insurance Data)',
      );

    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Backup failed: $e')),
      );
    }
  }
}

============================================================
PATH: .\lib\services\export_service.dart
============================================================

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import '../models/item.dart';

class ExportService {
  static Future<void> shareAsJson(List<Item> items) async {
    final jsonData = items.map((i) => i.toMap()).toList();
    final directory = await getTemporaryDirectory();
    final file = File('${directory.path}/inventory_export.json');
    await file.writeAsString(jsonEncode(jsonData));
    await Share.shareXFiles([XFile(file.path)], text: 'Inventory JSON Backup');
  }

  static Future<void> shareAsCsv(List<Item> items) async {
    List<List<dynamic>> rows = [
      ["Name", "Value", "Room", "Category", "Purchase Date", "Brand", "Model", "Serial", "Notes"]
    ];

    for (var i in items) {
      rows.add([
        i.name,
        i.value,
        i.room ?? "",
        i.category ?? "",
        i.purchaseDate.toIso8601String(),
        i.brand ?? "",
        i.model ?? "",
        i.serialNumber ?? "",
        i.notes ?? ""
      ]);
    }

    final csvData = const ListToCsvConverter().convert(rows);
    final directory = await getTemporaryDirectory();
    final file = File('${directory.path}/inventory_export.csv');
    await file.writeAsString(csvData);
    await Share.shareXFiles([XFile(file.path)], text: 'Inventory CSV Export');
  }
}

============================================================
PATH: .\lib\services\pdf_service.dart
============================================================

import 'dart:io';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'package:intl/intl.dart';
import '../models/item.dart';

class PdfService {
  static Future<void> generateInventoryReport(List<Item> items) async {
    final pdf = pw.Document();
    final totalValue = items.fold<double>(0, (sum, item) => sum + item.value);
    final currencyFormat = NumberFormat.simpleCurrency();

    // --- Page 1: Summary / Cover Page ---
    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        build: (context) => [
          pw.Header(
            level: 0,
            child: pw.Row(
              mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
              children: [
                pw.Text("Home Inventory Report", style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold)),
                pw.Text(DateFormat.yMMMd().format(DateTime.now())),
              ],
            ),
          ),
          pw.SizedBox(height: 20),
          pw.Container(
            padding: const pw.EdgeInsets.all(10),
            decoration: pw.BoxDecoration(color: PdfColors.grey100),
            child: pw.Row(
              mainAxisAlignment: pw.MainAxisAlignment.spaceAround,
              children: [
                _buildSummaryStat("Total Items", items.length.toString()),
                _buildSummaryStat("Total Value", currencyFormat.format(totalValue)),
              ],
            ),
          ),
          pw.SizedBox(height: 20),
          pw.TableHelper.fromTextArray(
            headerStyle: pw.TextStyle(fontWeight: pw.FontWeight.bold),
            context: context,
            data: <List<String>>[
              <String>['Name', 'Room', 'Category', 'Value'],
              ...items.map((i) => [i.name, i.room ?? 'N/A', i.category ?? 'N/A', currencyFormat.format(i.value)]),
            ],
          ),
        ],
      ),
    );

    // --- Detail Pages: Items & Images ---
    for (var item in items) {
      final List<pw.Widget> imageWidgets = [];

      // Convert file paths to PDF Images
      for (int i = 0; i < item.imagePaths.length; i++) {
        final file = File(item.imagePaths[i]);
        if (await file.exists()) {
          final image = pw.MemoryImage(file.readAsBytesSync());
          final isReceipt = item.receiptIndices.contains(i);

          imageWidgets.add(
            pw.Container(
              margin: const pw.EdgeInsets.all(5),
              decoration: pw.BoxDecoration(
                border: pw.Border.all(color: isReceipt ? PdfColors.green : PdfColors.grey300, width: 2),
              ),
              child: pw.Stack(
                alignment: pw.Alignment.bottomCenter,
                children: [
                  pw.Image(image, width: 150, height: 150, fit: pw.BoxFit.cover),
                  if (isReceipt)
                    pw.Container(
                      width: 150,
                      color: PdfColors.green,
                      padding: const pw.EdgeInsets.symmetric(vertical: 2),
                      child: pw.Text("RECEIPT",
                          textAlign: pw.TextAlign.center,
                          style: pw.TextStyle(color: PdfColors.white, fontSize: 8, fontWeight: pw.FontWeight.bold)),
                    ),
                ],
              ),
            ),
          );
        }
      }

      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (context) => pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Header(level: 1, text: item.name),
              pw.Row(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Expanded(
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        _buildDetailText("Value:", currencyFormat.format(item.value)),
                        _buildDetailText("Room:", item.room ?? "N/A"),
                        _buildDetailText("Category:", item.category ?? "N/A"),
                        _buildDetailText("Purchase Date:", DateFormat.yMMMd().format(item.purchaseDate)),
                        if (item.brand != null) _buildDetailText("Brand:", item.brand!),
                        if (item.model != null) _buildDetailText("Model:", item.model!),
                        if (item.serialNumber != null) _buildDetailText("Serial:", item.serialNumber!),
                      ],
                    ),
                  ),
                  pw.Expanded(
                    child: pw.Column(
                      crossAxisAlignment: pw.CrossAxisAlignment.start,
                      children: [
                        pw.Text("Notes:", style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
                        pw.Text(item.notes ?? "No notes provided."),
                      ],
                    ),
                  ),
                ],
              ),
              pw.SizedBox(height: 20),
              pw.Text("Photos & Proof of Purchase:", style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold)),
              pw.Divider(),
              pw.Wrap(children: imageWidgets),
            ],
          ),
        ),
      );
    }

    // Output the PDF to the native Print/Share dialog
    await Printing.layoutPdf(onLayout: (PdfPageFormat format) async => pdf.save());
  }

  static pw.Widget _buildSummaryStat(String label, String value) {
    return pw.Column(
      children: [
        pw.Text(label, style: const pw.TextStyle(fontSize: 12, color: PdfColors.grey700)),
        pw.Text(value, style: pw.TextStyle(fontSize: 18, fontWeight: pw.FontWeight.bold)),
      ],
    );
  }

  static pw.Widget _buildDetailText(String label, String value) {
    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 2),
      child: pw.RichText(
        text: pw.TextSpan(
          children: [
            pw.TextSpan(text: "$label ", style: pw.TextStyle(fontWeight: pw.FontWeight.bold)),
            pw.TextSpan(text: value),
          ],
        ),
      ),
    );
  }
}

============================================================
PATH: .\lib\services\zip_service.dart
============================================================

import 'dart:io';
import 'package:archive/archive_io.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import 'dart:developer' as dev;

class ZipService {
  // Point 14: Clear naming to avoid package collisions
  static Future<String> _getDatabasePath() async {
    final dbFolder = await getDatabasesPath();
    return p.join(dbFolder, 'inventory.db');
  }

  /// The main method used by your UI/Provider
  static Future<File?> createFullBackup(List<String> allImagePaths) async {
    try {
      final encoder = ZipFileEncoder();
      final tempDir = await getTemporaryDirectory();
      final zipPath = p.join(tempDir.path, 'inventory_backup.zip');

      encoder.create(zipPath);

      // 1. Add the Database File
      final dbFilePath = await _getDatabasePath();
      final dbFile = File(dbFilePath);

      if (dbFile.existsSync()) {
        encoder.addFile(dbFile);
      } else {
        dev.log("Backup Error: Database file not found at $dbFilePath");
      }

      // 2. Add Images (Point 8 & 11 logic)
      for (String path in allImagePaths) {
        if (path.isEmpty) continue;

        final imgFile = File(path);

        // Point 8: Verify file exists before archiving
        if (imgFile.existsSync()) {
          encoder.addFile(imgFile);
        } else {
          // Point 11: Log missing files instead of crashing the process
          dev.log("Backup Warning: Skipping missing image at $path");
        }
      }

      encoder.close();
      return File(zipPath);
    } catch (e) {
      dev.log("Critical Backup Failure: $e");
      return null;
    }
  }

  static Future<bool> importBackup(File zipFile) async {
    try {
      final bytes = await zipFile.readAsBytes();
      final archive = ZipDecoder().decodeBytes(bytes);
      final appDir = await getApplicationDocumentsDirectory();
      final dbPath = await _getDatabasePath();

      for (final file in archive) {
        final filename = file.name;
        if (file.isFile) {
          final data = file.content as List<int>;

          if (filename == 'inventory.db') {
            // 1. Handle Database Restore
            // We write to a temp file first to ensure integrity
            final tempDb = File('$dbPath.tmp');
            await tempDb.writeAsBytes(data);

            // Close existing connection before overwriting
            await databaseFactory.deleteDatabase(dbPath);
            await tempDb.rename(dbPath);
          } else {
            // 2. Handle Images Restore
            // Reconstruct the image in the app's document folder
            final outFile = File(p.join(appDir.path, filename));
            await outFile.create(recursive: true);
            await outFile.writeAsBytes(data);
          }
        }
      }
      return true;
    } catch (e) {
      dev.log("Import Failure: $e");
      return false;
    }
  }

}

============================================================
PATH: .\lib\widgets\barcode_scanner.dart
============================================================

import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';

class BarcodeScannerWidget extends StatefulWidget {
  const BarcodeScannerWidget({super.key});

  @override
  State<BarcodeScannerWidget> createState() => _BarcodeScannerWidgetState();
}

class _BarcodeScannerWidgetState extends State<BarcodeScannerWidget> {
  // MobileScannerController allows us to control the flash or switch cameras
  MobileScannerController cameraController = MobileScannerController();

  @override
  void dispose() {
    cameraController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan Serial Number'),
        actions: [
          // Flashlight toggle
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: cameraController,
              builder: (context, state, child) {
                // We handle all three states: off, on, and auto
                switch (state.torchState) {
                  case TorchState.off:
                    return const Icon(Icons.flash_off, color: Colors.grey);
                  case TorchState.on:
                    return const Icon(Icons.flash_on, color: Colors.yellow);
                  case TorchState.auto:
                    return const Icon(Icons.flash_auto, color: Colors.blueAccent);
                  case TorchState.unavailable:
                    // TODO: Handle this case.
                    throw UnimplementedError();
                }
              },
            ),
            onPressed: () => cameraController.toggleTorch(),
          ),
        ],
      ),
      body: MobileScanner(
        controller: cameraController,
        onDetect: (BarcodeCapture capture) { // Explicitly define BarcodeCapture
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty) {
            final String code = barcodes.first.rawValue ?? "Unknown";
            Navigator.pop(context, code);
          }
        },
      ),
    );
  }
}

============================================================
PATH: .\test\widget_test.dart
============================================================

