FLUTTER PROJECT CODEBASE BUNDLE
Generated for Gemini Analysis


============================================================
PATH: .\analysis_options.yaml
============================================================

# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options


============================================================
PATH: .\devtools_options.yaml
============================================================

description: This file stores settings for Dart & Flutter DevTools.
documentation: https://docs.flutter.dev/tools/devtools/extensions#configure-extension-enablement-states
extensions:


============================================================
PATH: .\pubspec.yaml
============================================================

name: home_inventory
description: "A new Flutter project."
publish_to: 'none'

version: 1.0.0+1

environment:
  sdk: ^3.10.8

# Section 1: Packages your app NEEDS to run
dependencies:
  flutter:
    sdk: flutter
  provider: ^6.1.1
  sqflite: ^2.3.0
  path: ^1.8.3
  image_picker: ^1.0.4
  path_provider: ^2.1.1
  intl: ^0.20.2
  archive: ^4.0.7
  share_plus: ^12.0.1
  shared_preferences: ^2.5.4
  pdf: ^3.10.7
  printing: ^5.11.1
  flutter_image_compress: ^2.3.0
  mobile_scanner: ^5.2.0
  file_picker: ^8.0.0
  csv: ^5.0.2
  speech_to_text: ^7.0.0
  camera: ^0.10.5+5
  permission_handler: ^11.0.0
  flutter_speed_dial: ^7.0.0

# Section 2: Tools for you (the developer) only
dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true

============================================================
PATH: .\lib\main.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'providers/inventory_provider.dart';
import 'providers/settings_provider.dart';
import 'providers/metadata_provider.dart'; // NEW IMPORT
import 'screens/home_screen.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        // 1. Inventory Data (Items)
        ChangeNotifierProvider(
          create: (context) => InventoryProvider()..initializeData(),
        ),
        // 2. Metadata (Rooms & Categories) - SEPARATED
        ChangeNotifierProvider(
          create: (context) => MetadataProvider(), // Auto-loads on init
        ),
        // 3. Settings (Theme, Profile)
        ChangeNotifierProvider(
          create: (context) => SettingsProvider(),
        ),
      ],
      child: Consumer<SettingsProvider>(
        builder: (context, settings, child) {
          return MaterialApp(
            title: 'Home Inventory',
            debugShowCheckedModeBanner: false,
            theme: ThemeData(
              colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
              useMaterial3: true,
            ),
            darkTheme: ThemeData(
              colorScheme: ColorScheme.fromSeed(
                seedColor: Colors.blue,
                brightness: Brightness.dark,
              ),
              useMaterial3: true,
            ),
            themeMode: settings.themeMode,
            home: const HomeScreen(),
          );
        },
      ),
    );
  }
}

============================================================
PATH: .\lib\data\database_helper.dart
============================================================

import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import '../models/item.dart';
import '../services/logger_service.dart';
import '../providers/inventory_provider.dart';
import '../utils/app_constants.dart'; // NEW IMPORT

class DatabaseHelper {
  static final DatabaseHelper instance = DatabaseHelper._init();
  static Database? _database;

  DatabaseHelper._init();

  static const String _dbName = 'inventory.db';
  static const int _dbVersion = 6;

  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB(_dbName);
    return _database!;
  }

  Future<Database> _initDB(String filePath) async {
    final dbPath = await getDatabasesPath();
    final path = join(dbPath, filePath);
    logger.log("DB: Initializing at $path");

    return await openDatabase(
      path,
      version: _dbVersion,
      onCreate: _createDB,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> close() async {
    final db = _database;
    if (db != null) {
      await db.close();
      _database = null;
      logger.log("DB: Connection closed.");
    }
  }

  Future _createDB(Database db, int version) async {
    // 1. Items Table
    await db.execute('''
      CREATE TABLE items (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        value REAL NOT NULL,
        purchaseDate TEXT NOT NULL,
        warrantyExpiry TEXT,
        imagePaths TEXT NOT NULL,
        receiptIndices TEXT,
        room TEXT,
        category TEXT,
        serialNumber TEXT,
        brand TEXT,
        model TEXT,
        notes TEXT
      )
    ''');

    // 2. Metadata Tables
    await db.execute('CREATE TABLE rooms (name TEXT PRIMARY KEY)');
    await db.execute('CREATE TABLE categories (name TEXT PRIMARY KEY)');

    // 3. Seed Data from Constants (NO HARDCODING HERE)
    final batch = db.batch();
    for (var r in AppConstants.defaultRooms) {
      batch.insert('rooms', {'name': r}, conflictAlgorithm: ConflictAlgorithm.ignore);
    }
    for (var c in AppConstants.defaultCategories) {
      batch.insert('categories', {'name': c}, conflictAlgorithm: ConflictAlgorithm.ignore);
    }
    await batch.commit(noResult: true);

    // 4. FTS Setup
    await _setupFTS(db);

    logger.log("DB: Created and Seeded.");
  }

  Future _onUpgrade(Database db, int oldVersion, int newVersion) async {
    if (oldVersion < 5) {
      try {
        await db.execute('ALTER TABLE items ADD COLUMN warrantyExpiry TEXT');
        await db.execute('ALTER TABLE items ADD COLUMN receiptIndices TEXT');
      } catch (e) {}
    }
    if (oldVersion < 6) {
      await _setupFTS(db);
      await db.execute('''
        INSERT INTO items_fts(docid, name, brand, model, serialNumber, room, category, notes)
        SELECT id, name, brand, model, serialNumber, room, category, notes FROM items
      ''');
    }
  }

  Future<void> _setupFTS(Database db) async {
    await db.execute('''
      CREATE VIRTUAL TABLE items_fts USING fts4(
        content="items",
        name, brand, model, serialNumber, room, category, notes
      )
    ''');
    await db.execute('''
      CREATE TRIGGER items_bu AFTER INSERT ON items BEGIN
        INSERT INTO items_fts(docid, name, brand, model, serialNumber, room, category, notes)
        VALUES(new.id, new.name, new.brand, new.model, new.serialNumber, new.room, new.category, new.notes);
      END;
    ''');
    await db.execute('''
      CREATE TRIGGER items_bd AFTER DELETE ON items BEGIN
        DELETE FROM items_fts WHERE docid = old.id;
      END;
    ''');
    await db.execute('''
      CREATE TRIGGER items_bu_update AFTER UPDATE ON items BEGIN
        DELETE FROM items_fts WHERE docid = old.id;
        INSERT INTO items_fts(docid, name, brand, model, serialNumber, room, category, notes)
        VALUES(new.id, new.name, new.brand, new.model, new.serialNumber, new.room, new.category, new.notes);
      END;
    ''');
  }

  // --- QUERIES ---

  Future<List<Item>> queryItems({
    required String query,
    required SortOption sortOption,
    int limit = 20,
    int offset = 0,
  }) async {
    final db = await instance.database;
    String orderBy;
    switch (sortOption) {
      case SortOption.name:  orderBy = 'name ASC'; break;
      case SortOption.value: orderBy = 'value DESC'; break;
      case SortOption.date:  orderBy = 'purchaseDate DESC'; break;
    }

    if (query.trim().isEmpty) {
      final result = await db.query('items', orderBy: orderBy, limit: limit, offset: offset);
      return result.map((json) => Item.fromMap(json)).toList();
    }

    final sanitized = query.replaceAll(RegExp(r'[^\w\s\-]'), '');
    if (sanitized.isEmpty) return [];

    final sql = '''
      SELECT items.* FROM items 
      JOIN items_fts ON items.id = items_fts.docid
      WHERE items_fts MATCH '$sanitized*' 
      ORDER BY items.$orderBy
      LIMIT $limit OFFSET $offset
    ''';

    try {
      final result = await db.rawQuery(sql);
      return result.map((json) => Item.fromMap(json)).toList();
    } catch (e) {
      return [];
    }
  }

  Future<double> getTotalValue() async {
    final db = await instance.database;
    final result = await db.rawQuery('SELECT SUM(value) as total FROM items');
    if (result.isNotEmpty && result.first['total'] != null) {
      return (result.first['total'] as num).toDouble();
    }
    return 0.0;
  }

  // --- CRUD ---
  Future<Item> create(Item item) async {
    final db = await instance.database;
    final id = await db.insert('items', item.toMap());
    return item.copyWith(id: id);
  }

  Future<List<Item>> readAllItems() async {
    final db = await instance.database;
    final result = await db.query('items', orderBy: 'name ASC');
    return result.map((json) => Item.fromMap(json)).toList();
  }

  Future<int> update(Item item) async {
    final db = await instance.database;
    return await db.update('items', item.toMap(), where: 'id = ?', whereArgs: [item.id]);
  }

  Future<int> delete(int id) async {
    final db = await instance.database;
    return await db.delete('items', where: 'id = ?', whereArgs: [id]);
  }

  Future<int> deleteAllItems() async {
    final db = await instance.database;
    return await db.delete('items');
  }

  // --- METADATA (Low Level) ---

  Future<List<String>> getRooms() async {
    final db = await database;
    final res = await db.query('rooms', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveRooms(List<String> rooms) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('rooms');
      for (var r in rooms) {
        await txn.insert('rooms', {'name': r}, conflictAlgorithm: ConflictAlgorithm.replace);
      }
    });
  }

  Future<List<String>> getCategories() async {
    final db = await database;
    final res = await db.query('categories', orderBy: 'name ASC');
    return res.map((e) => e['name'] as String).toList();
  }

  Future<void> saveCategories(List<String> categories) async {
    final db = await database;
    await db.transaction((txn) async {
      await txn.delete('categories');
      for (var c in categories) {
        await txn.insert('categories', {'name': c}, conflictAlgorithm: ConflictAlgorithm.replace);
      }
    });
  }
}

============================================================
PATH: .\lib\models\item.dart
============================================================

import 'dart:convert';

class Item {
  final int? id;
  final String name;
  final List<String> imagePaths;
  final double value;
  final DateTime purchaseDate;
  final DateTime? warrantyExpiry;
  final String? serialNumber;
  final String? brand;
  final String? model;
  final String? notes;
  final String? room;
  final String? category;
  final List<int> receiptIndices; // Indices of images that are receipts

  Item({
    this.id,
    required this.name,
    required this.imagePaths,
    required this.value,
    required this.purchaseDate,
    this.warrantyExpiry,
    this.serialNumber,
    this.brand,
    this.model,
    this.notes,
    this.room,
    this.category,
    this.receiptIndices = const []
  });

  /// Creates a copy of this Item but with the given fields replaced with new values.
  /// This is essential for updating immutable (final) data in Flutter.
  Item copyWith({
    int? id,
    String? name,
    List<String>? imagePaths,
    double? value,
    DateTime? purchaseDate,
    DateTime? warrantyExpiry,
    String? serialNumber,
    String? brand,
    String? model,
    String? notes,
    String? room,
    String? category,
    List<int>? receiptIndices,
  }) {
    return Item(
      id: id ?? this.id,
      name: name ?? this.name,
      imagePaths: imagePaths ?? this.imagePaths,
      value: value ?? this.value,
      purchaseDate: purchaseDate ?? this.purchaseDate,
      warrantyExpiry: warrantyExpiry ?? this.warrantyExpiry,
      serialNumber: serialNumber ?? this.serialNumber,
      brand: brand ?? this.brand,
      model: model ?? this.model,
      notes: notes ?? this.notes,
      room: room ?? this.room,
      category: category ?? this.category,
      receiptIndices: receiptIndices ?? this.receiptIndices,
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'imagePaths': jsonEncode(imagePaths),
      'value': value,
      'purchaseDate': purchaseDate.toIso8601String(),
      'warrantyExpiry': warrantyExpiry?.toIso8601String(),
      'serialNumber': serialNumber,
      'brand': brand,
      'model': model,
      'notes': notes,
      'room': room,
      'category': category,
      'receiptIndices': jsonEncode(receiptIndices),
    };
  }

  factory Item.fromMap(Map<String, dynamic> map) {
    return Item(
      id: map['id'],
      name: map['name'],
      imagePaths: List<String>.from(jsonDecode(map['imagePaths'])),
      value: (map['value'] as num).toDouble(),
      purchaseDate: DateTime.parse(map['purchaseDate']),
      warrantyExpiry: map['warrantyExpiry'] != null
          ? DateTime.parse(map['warrantyExpiry'])
          : null,
      serialNumber: map['serialNumber'],
      brand: map['brand'],
      model: map['model'],
      notes: map['notes'],
      room: map['room'],
      category: map['category'],
      receiptIndices: map['receiptIndices'] != null
          ? List<int>.from(jsonDecode(map['receiptIndices']))
          : [],
    );
  }
}

============================================================
PATH: .\lib\providers\inventory_provider.dart
============================================================

import 'dart:async'; // NEW: Required for Timer
import 'package:flutter/material.dart';
import '../models/item.dart';
import '../repositories/inventory_repository.dart';
import '../services/logger_service.dart';

enum SortOption { name, value, date }

class InventoryProvider with ChangeNotifier {
  // Dependency Injection: Repository handles Data/Files
  final InventoryRepository _repository = InventoryRepository();

  // --- DEBOUNCE TIMER ---
  Timer? _debounce; // NEW: Holds the active timer

  // --- PAGINATION STATE ---
  List<Item> _items = [];
  bool _isLoading = false;
  bool _isLoadingMore = false;
  bool _hasMoreData = true;
  int _currentPage = 0;
  static const int _pageSize = 20;

  // Search & Sort State
  String _searchQuery = '';
  SortOption _currentSort = SortOption.name;

  // Stats
  double _totalValue = 0.0;

  // Getters
  List<Item> get items => _items;
  List<Item> get filteredItems => _items;

  bool get isLoading => _isLoading;
  bool get isLoadingMore => _isLoadingMore;
  String get searchQuery => _searchQuery;
  SortOption get currentSort => _currentSort;
  double get totalValue => _totalValue;

  // --- LIFECYCLE ---

  @override
  void dispose() {
    _debounce?.cancel(); // NEW: Cleanup timer on dispose
    super.dispose();
  }

  // --- INITIALIZATION ---

  Future<void> initializeData() async {
    _isLoading = true;
    notifyListeners();
    await _resetAndReload();
    _isLoading = false;
    notifyListeners();
  }

  Future<void> refreshAfterImport() async {
    await initializeData();
  }

  Future<void> _refreshTotalValue() async {
    _totalValue = await _repository.getTotalValue();
  }

  /// Resets pagination and loads Page 0
  Future<void> _resetAndReload() async {
    _currentPage = 0;
    _hasMoreData = true;
    _items.clear();

    await _performQuery();
    await _refreshTotalValue();
  }

  // --- PAGINATION LOGIC ---

  Future<void> loadNextPage() async {
    if (_isLoadingMore || !_hasMoreData) return;

    _isLoadingMore = true;
    notifyListeners();

    _currentPage++;
    await _performQuery(isLoadMore: true);

    _isLoadingMore = false;
    notifyListeners();
  }

  Future<void> _performQuery({bool isLoadMore = false}) async {
    try {
      final newItems = await _repository.getItems(
        query: _searchQuery,
        sortOption: _currentSort,
        limit: _pageSize,
        offset: _currentPage * _pageSize,
      );

      if (newItems.length < _pageSize) {
        _hasMoreData = false;
      }

      if (isLoadMore) {
        _items.addAll(newItems);
      } else {
        _items = newItems;
      }
    } catch (e) {
      logger.log("Provider Error: Query failed", error: e);
      if (!isLoadMore) _items = [];
    }
  }

  // --- USER ACTIONS ---

  /// NEW: Debounced Search
  /// Waits 500ms after the last keystroke before hitting the database.
  void setSearchQuery(String query) {
    if (_searchQuery == query) return;

    // 1. Update the value immediately so UI text fields don't lag
    _searchQuery = query;

    // 2. Cancel previous timer if the user is still typing
    if (_debounce?.isActive ?? false) _debounce!.cancel();

    // 3. Start a new timer
    _debounce = Timer(const Duration(milliseconds: 500), () {
      // 4. Only trigger the DB query when the timer finishes
      _resetAndReload().then((_) => notifyListeners());
    });
  }

  void setSort(SortOption option) {
    if (_currentSort == option) return;
    _currentSort = option;
    _resetAndReload().then((_) => notifyListeners());
  }

  // --- CRUD ACTIONS ---

  Future<void> addItem(Item item) async {
    await _repository.createItem(item);
    await _resetAndReload();
    notifyListeners();
  }

  Future<void> updateItem(Item item) async {
    await _repository.updateItem(item);
    await _resetAndReload();
    notifyListeners();
  }

  Future<void> deleteItem(int id) async {
    try {
      await _repository.deleteItem(id);

      _items.removeWhere((i) => i.id == id);
      await _refreshTotalValue();
      notifyListeners();

      logger.log("Provider: Item $id deleted.");
    } catch (e) {
      logger.log("Provider Error deleting item $id", error: e);
    }
  }

  Future<void> clearAll() async {
    await _repository.clearAllItems();

    _items.clear();
    _totalValue = 0.0;
    _currentPage = 0;
    notifyListeners();
  }

  // --- HELPERS ---
  int getItemsCountInRoom(String roomName) => _items.where((i) => i.room == roomName).length;
  int getItemsCountInCategory(String catName) => _items.where((i) => i.category == catName).length;
}

============================================================
PATH: .\lib\providers\metadata_provider.dart
============================================================

import 'package:flutter/material.dart';
import '../repositories/metadata_repository.dart'; // Uses Repo, not DB Helper
import '../services/logger_service.dart';

class MetadataProvider with ChangeNotifier {
  final MetadataRepository _repository = MetadataRepository();

  List<String> _rooms = [];
  List<String> _categories = [];
  bool _isLoading = false;

  List<String> get rooms => _rooms;
  List<String> get categories => _categories;
  bool get isLoading => _isLoading;

  MetadataProvider() {
    loadMetadata();
  }

  Future<void> loadMetadata() async {
    _isLoading = true;
    notifyListeners();

    try {
      final results = await Future.wait([
        _repository.getRooms(),
        _repository.getCategories(),
      ]);
      _rooms = results[0];
      _categories = results[1];
    } catch (e) {
      logger.log("MetadataProvider Error: Load failed", error: e);
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  // --- ROOMS ---

  Future<void> addRoom(String name) async {
    final trimmed = name.trim();
    if (trimmed.isNotEmpty && !_rooms.contains(trimmed)) {
      _rooms.add(trimmed);
      _rooms.sort();
      await _repository.saveRooms(_rooms);
      notifyListeners();
    }
  }

  Future<void> removeRoom(String name) async {
    _rooms.remove(name);
    await _repository.saveRooms(_rooms);
    notifyListeners();
  }

  // --- CATEGORIES ---

  Future<void> addCategory(String name) async {
    final trimmed = name.trim();
    if (trimmed.isNotEmpty && !_categories.contains(trimmed)) {
      _categories.add(trimmed);
      _categories.sort();
      await _repository.saveCategories(_categories);
      notifyListeners();
    }
  }

  Future<void> removeCategory(String name) async {
    _categories.remove(name);
    await _repository.saveCategories(_categories);
    notifyListeners();
  }
}

============================================================
PATH: .\lib\providers\settings_provider.dart
============================================================

import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class SettingsProvider with ChangeNotifier {
  String _userName = "";
  String _address = "";
  String _policyNumber = "";
  ThemeMode _themeMode = ThemeMode.system;

  String get userName => _userName;
  String get address => _address;
  String get policyNumber => _policyNumber;
  ThemeMode get themeMode => _themeMode;
  String _insuranceCompany = "";
  String get insuranceCompany => _insuranceCompany;

  SettingsProvider() {
    _loadSettings();
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    _userName = prefs.getString('userName') ?? "";
    _address = prefs.getString('address') ?? "";
    _policyNumber = prefs.getString('policyNumber') ?? "";
    _themeMode = ThemeMode.values[prefs.getInt('themeMode') ?? 0];
    _insuranceCompany = prefs.getString('insuranceCompany') ?? "";
    notifyListeners();
  }

  Future<void> updateProfile(String name, String addr, String policy, String company) async {
    final prefs = await SharedPreferences.getInstance();
    _userName = name;
    _address = addr;
    _policyNumber = policy;
    _insuranceCompany = company;
    await prefs.setString('userName', name);
    await prefs.setString('address', addr);
    await prefs.setString('policyNumber', policy);
    await prefs.setString('insuranceCompany', company);
    notifyListeners();
  }

  Future<void> setThemeMode(ThemeMode mode) async {
    final prefs = await SharedPreferences.getInstance();
    _themeMode = mode;
    await prefs.setInt('themeMode', mode.index);
    notifyListeners();
  }
}

============================================================
PATH: .\lib\repositories\inventory_repository.dart
============================================================

import 'dart:io';
import '../models/item.dart';
import '../data/database_helper.dart';
import '../services/logger_service.dart';
import '../providers/inventory_provider.dart'; // Needed for SortOption enum

class InventoryRepository {
  // Singleton access to the Database
  final DatabaseHelper _db = DatabaseHelper.instance;

  /// Fetch items with Search, Sort, and Pagination support
  Future<List<Item>> getItems({
    required String query,
    required SortOption sortOption,
    int limit = 20,
    int offset = 0,
  }) async {
    return await _db.queryItems(
      query: query,
      sortOption: sortOption,
      limit: limit,
      offset: offset,
    );
  }

  /// Get the total value of the inventory
  Future<double> getTotalValue() async {
    return await _db.getTotalValue();
  }

  /// Create a new item
  Future<Item> createItem(Item item) async {
    return await _db.create(item);
  }

  /// Update an existing item
  Future<int> updateItem(Item item) async {
    return await _db.update(item);
  }

  /// Delete an item AND its associated images
  Future<void> deleteItem(int id) async {
    try {
      // 1. Fetch item first to get image paths (Using internal helper or direct query)
      // We perform a specific query here to ensure we get the paths before deletion
      // even if the item isn't currently loaded in the UI list.
      final db = await _db.database;
      final results = await db.query('items', where: 'id = ?', whereArgs: [id]);

      if (results.isNotEmpty) {
        final item = Item.fromMap(results.first);

        // 2. Delete Physical Files
        for (String path in item.imagePaths) {
          await _deleteFileSafe(path);
        }
      }

      // 3. Delete DB Record
      await _db.delete(id);
      logger.log("Repo: Item $id and associated files deleted.");
    } catch (e) {
      logger.log("Repo Error: Failed to delete item $id", error: e);
      rethrow;
    }
  }

  /// Wipe entire inventory AND all associated images
  Future<void> clearAllItems() async {
    try {
      // 1. Fetch ALL items to get paths
      final allItems = await _db.readAllItems();

      // 2. Delete All Files
      for (var item in allItems) {
        for (var path in item.imagePaths) {
          await _deleteFileSafe(path);
        }
      }

      // 3. Wipe DB
      await _db.deleteAllItems();
      logger.log("Repo: All items and files cleared.");
    } catch (e) {
      logger.log("Repo Error: Failed to clear all items", error: e);
      rethrow;
    }
  }

  /// Helper: Safely delete a file
  Future<void> _deleteFileSafe(String path) async {
    try {
      final file = File(path);
      if (await file.exists()) {
        await file.delete();
      }
    } catch (e) {
      logger.log("Repo Warning: Could not delete file $path", error: e);
    }
  }
}

============================================================
PATH: .\lib\repositories\list_repository.dart
============================================================

import '../data/database_helper.dart';

class ListRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;

  // Rooms logic
  Future<List<String>> fetchRooms() async {
    final rooms = await _db.getRooms();
    // Professional touch: If DB is empty, provide defaults but don't save them yet
    if (rooms.isEmpty) {
      return ['Living Room', 'Kitchen', 'Bedroom', 'Garage', 'Office'];
    }
    return rooms;
  }

  Future<void> updateRooms(List<String> rooms) => _db.saveRooms(rooms);

  // Categories logic
  Future<List<String>> fetchCategories() async {
    final categories = await _db.getCategories();
    if (categories.isEmpty) {
      return ['Electronics', 'Furniture', 'Jewelry', 'Tools', 'Appliances'];
    }
    return categories;
  }

  Future<void> updateCategories(List<String> categories) => _db.saveCategories(categories);
}

============================================================
PATH: .\lib\repositories\metadata_repository.dart
============================================================

import '../data/database_helper.dart';
import '../utils/app_constants.dart';

class MetadataRepository {
  final DatabaseHelper _db = DatabaseHelper.instance;

  // --- ROOMS ---

  Future<List<String>> getRooms() async {
    final rooms = await _db.getRooms();
    // FALLBACK: If DB is empty for some reason, return defaults
    if (rooms.isEmpty) {
      return AppConstants.defaultRooms;
    }
    return rooms;
  }

  Future<void> saveRooms(List<String> rooms) async {
    await _db.saveRooms(rooms);
  }

  // --- CATEGORIES ---

  Future<List<String>> getCategories() async {
    final categories = await _db.getCategories();
    // FALLBACK
    if (categories.isEmpty) {
      return AppConstants.defaultCategories;
    }
    return categories;
  }

  Future<void> saveCategories(List<String> categories) async {
    await _db.saveCategories(categories);
  }

  /// Optional: Reset to factory defaults
  Future<void> resetDefaults() async {
    await saveRooms(AppConstants.defaultRooms);
    await saveCategories(AppConstants.defaultCategories);
  }
}

============================================================
PATH: .\lib\screens\add_item_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as path;
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import '../providers/metadata_provider.dart'; // NEW IMPORT
import 'package:flutter_image_compress/flutter_image_compress.dart';
// import '../widgets/barcode_scanner.dart'; // Uncomment if you have this widget

class AddItemScreen extends StatefulWidget {
  final Item? itemToEdit;
  const AddItemScreen({super.key, this.itemToEdit});

  @override
  State<AddItemScreen> createState() => _AddItemScreenState();
}

class _AddItemScreenState extends State<AddItemScreen> {
  final _formKey = GlobalKey<FormState>();

  // Controllers
  final _nameController = TextEditingController();
  final _valueController = TextEditingController();
  final _serialController = TextEditingController();
  final _brandController = TextEditingController();
  final _modelController = TextEditingController();
  final _notesController = TextEditingController();

  // State
  List<File> _imageFiles = [];
  List<int> _receiptIndices = [];
  String? _selectedRoom;
  String? _selectedCategory;
  DateTime _purchaseDate = DateTime.now();
  DateTime? _warrantyExpiry;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    if (widget.itemToEdit != null) {
      final item = widget.itemToEdit!;
      _nameController.text = item.name;
      _valueController.text = item.value == 0.0 ? '' : item.value.toString();
      _serialController.text = item.serialNumber ?? '';
      _brandController.text = item.brand ?? '';
      _modelController.text = item.model ?? '';
      _notesController.text = item.notes ?? '';
      _selectedRoom = item.room;
      _selectedCategory = item.category;
      _purchaseDate = item.purchaseDate;
      _warrantyExpiry = item.warrantyExpiry;
      _receiptIndices = List.from(item.receiptIndices);
      _imageFiles = item.imagePaths.map((path) => File(path)).toList();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _valueController.dispose();
    _serialController.dispose();
    _brandController.dispose();
    _modelController.dispose();
    _notesController.dispose();
    super.dispose();
  }

  // --- LOGIC ---

  Future<void> _pickImage(ImageSource source) async {
    final picker = ImagePicker();
    final pickedFile = await picker.pickImage(source: source, imageQuality: 75);
    if (pickedFile != null) {
      setState(() => _imageFiles.add(File(pickedFile.path)));
    }
  }

  Future<void> _selectDate(BuildContext context, bool isPurchaseDate) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: isPurchaseDate ? _purchaseDate : (_warrantyExpiry ?? DateTime.now().add(const Duration(days: 365))),
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) {
      setState(() {
        if (isPurchaseDate) _purchaseDate = picked; else _warrantyExpiry = picked;
      });
    }
  }

  Future<void> _saveItem() async {
    if (_isSaving || !_formKey.currentState!.validate()) return;

    if (_imageFiles.isEmpty) {
      ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('At least one photo is required.')));
      return;
    }

    setState(() => _isSaving = true);

    try {
      final appDir = await getApplicationDocumentsDirectory();
      List<String> savedPaths = [];

      for (var file in _imageFiles) {
        if (file.path.contains(appDir.path)) {
          savedPaths.add(file.path);
        } else {
          final fileName = 'img_${DateTime.now().millisecondsSinceEpoch}_${path.basename(file.path)}';
          final targetPath = '${appDir.path}/$fileName';

          var result = await FlutterImageCompress.compressAndGetFile(
            file.absolute.path, targetPath,
            quality: 70, minWidth: 1024, minHeight: 1024,
          );

          savedPaths.add(result?.path ?? (await file.copy(targetPath)).path);
        }
      }

      final newItem = Item(
        id: widget.itemToEdit?.id,
        name: _nameController.text.trim(),
        imagePaths: savedPaths,
        value: double.tryParse(_valueController.text.replaceAll(',', '')) ?? 0.0,
        purchaseDate: _purchaseDate,
        warrantyExpiry: _warrantyExpiry,
        serialNumber: _serialController.text.isEmpty ? null : _serialController.text,
        brand: _brandController.text.isEmpty ? null : _brandController.text,
        model: _modelController.text.isEmpty ? null : _modelController.text,
        notes: _notesController.text.isEmpty ? null : _notesController.text,
        room: (_selectedRoom == "None" || _selectedRoom == null) ? null : _selectedRoom,
        category: (_selectedCategory == "None" || _selectedCategory == null) ? null : _selectedCategory,
        receiptIndices: _receiptIndices,
      );

      final provider = Provider.of<InventoryProvider>(context, listen: false);
      if (widget.itemToEdit == null) {
        await provider.addItem(newItem);
      } else {
        await provider.updateItem(newItem);
      }

      if (mounted) Navigator.pop(context);
    } catch (e) {
      if (mounted) ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Error: $e')));
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  // --- UI ---

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // CHANGED: Watch MetadataProvider for rooms/categories
    final metadata = context.watch<MetadataProvider>();

    final roomOptions = ["None", ...metadata.rooms];
    final categoryOptions = ["None", ...metadata.categories];

    return Scaffold(
      appBar: AppBar(title: Text(widget.itemToEdit == null ? 'Add Full Item' : 'Edit Item')),
      body: _isSaving ? const Center(child: CircularProgressIndicator()) : SingleChildScrollView(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildPhotoHeader(),
              _buildPhotoGallery(theme),
              const SizedBox(height: 24),

              _buildTextField(_nameController, 'Item Name', Icons.inventory_2, isRequired: true),
              _buildTextField(_valueController, 'Estimated Value (\$)', Icons.monetization_on, isNumber: true),

              Row(
                children: [
                  Expanded(child: _buildDatePicker('Purchase Date', _purchaseDate, () => _selectDate(context, true))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDatePicker('Warranty Until', _warrantyExpiry, () => _selectDate(context, false), isOptional: true)),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildDropdown('Room', _selectedRoom, roomOptions, (val) => setState(() => _selectedRoom = val))),
                  const SizedBox(width: 12),
                  Expanded(child: _buildDropdown('Category', _selectedCategory, categoryOptions, (val) => setState(() => _selectedCategory = val))),
                ],
              ),

              Row(
                children: [
                  Expanded(child: _buildTextField(_brandController, 'Brand', Icons.factory)),
                  const SizedBox(width: 12),
                  Expanded(child: _buildTextField(_modelController, 'Model #', Icons.label_important)),
                ],
              ),

              _buildScanTextField(_serialController, 'Serial Number / UPC', Icons.qr_code_scanner),
              _buildTextField(_notesController, 'Notes / Description', Icons.description, maxLines: 3),

              const SizedBox(height: 32),
              _buildSaveButton(theme),
              const SizedBox(height: 50),
            ],
          ),
        ),
      ),
    );
  }

  // --- WIDGET BUILDERS ---

  Widget _buildTextField(TextEditingController controller, String label, IconData icon, {bool isNumber = false, bool isRequired = false, int maxLines = 1}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        keyboardType: isNumber ? const TextInputType.numberWithOptions(decimal: true) : TextInputType.text,
        maxLines: maxLines,
        validator: isRequired ? (val) => val == null || val.isEmpty ? 'Required' : null : null,
        decoration: InputDecoration(
          labelText: label,
          prefixIcon: Icon(icon),
          border: const OutlineInputBorder(),
        ),
      ),
    );
  }

  Widget _buildScanTextField(TextEditingController controller, String label, IconData icon) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: TextFormField(
        controller: controller,
        decoration: InputDecoration(
          labelText: label,
          prefixIcon: Icon(icon),
          border: const OutlineInputBorder(),
          suffixIcon: IconButton(
            icon: const Icon(Icons.center_focus_weak),
            onPressed: () {
              // Add Barcode Scanner logic here if needed
            },
          ),
        ),
      ),
    );
  }

  Widget _buildDropdown(String label, String? value, List<String> options, Function(String?) onChanged) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 16),
      child: DropdownButtonFormField<String>(
        value: options.contains(value) ? value : null,
        decoration: InputDecoration(labelText: label, border: const OutlineInputBorder()),
        items: options.map((String val) {
          return DropdownMenuItem<String>(
            value: val,
            child: Text(val),
          );
        }).toList(),
        onChanged: onChanged,
      ),
    );
  }

  Widget _buildDatePicker(String label, DateTime? date, VoidCallback onTap, {bool isOptional = false}) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        margin: const EdgeInsets.only(bottom: 16),
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 16),
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(label, style: const TextStyle(fontSize: 12, color: Colors.grey)),
            const SizedBox(height: 4),
            Text(
              date == null ? 'Not Set' : DateFormat.yMMMd().format(date),
              style: const TextStyle(fontSize: 16),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSaveButton(ThemeData theme) {
    return SizedBox(
      width: double.infinity,
      child: ElevatedButton.icon(
        onPressed: _saveItem,
        style: ElevatedButton.styleFrom(
          padding: const EdgeInsets.symmetric(vertical: 16),
          backgroundColor: theme.colorScheme.primary,
          foregroundColor: theme.colorScheme.onPrimary,
        ),
        icon: const Icon(Icons.save),
        label: const Text('SAVE ITEM', style: TextStyle(fontWeight: FontWeight.bold)),
      ),
    );
  }

  Widget _buildPhotoHeader() {
    return const Padding(
      padding: EdgeInsets.only(bottom: 8),
      child: Text("Photos & Receipts *", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
    );
  }

  Widget _buildPhotoGallery(ThemeData theme) {
    return SizedBox(
      height: 140,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: _imageFiles.length + 1,
        itemBuilder: (ctx, i) {
          if (i == _imageFiles.length) return _buildAddPhotoButton(theme);
          bool isReceipt = _receiptIndices.contains(i);
          return _buildPhotoPreview(i, isReceipt);
        },
      ),
    );
  }

  Widget _buildAddPhotoButton(ThemeData theme) {
    return GestureDetector(
      onTap: () => _showImageSourceSheet(),
      child: Container(
        width: 110,
        margin: const EdgeInsets.only(right: 12, top: 10),
        decoration: BoxDecoration(
          color: theme.colorScheme.surfaceVariant,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.colorScheme.outlineVariant, width: 1),
        ),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.add_a_photo, color: theme.colorScheme.primary),
            const SizedBox(height: 8),
            Text("Add Photo", style: TextStyle(fontSize: 12, color: theme.colorScheme.onSurfaceVariant)),
          ],
        ),
      ),
    );
  }

  Widget _buildPhotoPreview(int index, bool isReceipt) {
    return Stack(
      children: [
        Container(
          margin: const EdgeInsets.only(right: 12, top: 10),
          width: 110,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            image: DecorationImage(image: FileImage(_imageFiles[index]), fit: BoxFit.cover),
            border: Border.all(color: isReceipt ? Colors.green : Colors.transparent, width: 3),
          ),
        ),
        Positioned(
          right: 0, top: 0,
          child: GestureDetector(
            onTap: () => setState(() {
              _imageFiles.removeAt(index);
              _receiptIndices.remove(index);
              _receiptIndices = _receiptIndices.map((e) => e > index ? e - 1 : e).toList();
            }),
            child: const CircleAvatar(radius: 12, backgroundColor: Colors.red, child: Icon(Icons.close, size: 16, color: Colors.white)),
          ),
        ),
        Positioned(
          left: 5, bottom: 5,
          child: GestureDetector(
            onTap: () => setState(() => _receiptIndices.contains(index) ? _receiptIndices.remove(index) : _receiptIndices.add(index)),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(color: isReceipt ? Colors.green : Colors.black54, borderRadius: BorderRadius.circular(8)),
              child: Row(children: [
                const Icon(Icons.receipt_long, size: 12, color: Colors.white),
                const SizedBox(width: 4),
                Text(isReceipt ? "Receipt" : "Mark Receipt", style: const TextStyle(color: Colors.white, fontSize: 10)),
              ]),
            ),
          ),
        ),
      ],
    );
  }

  void _showImageSourceSheet() {
    showModalBottomSheet(
      context: context,
      builder: (ctx) => SafeArea(
        child: Wrap(
          children: [
            ListTile(leading: const Icon(Icons.photo_library), title: const Text('Gallery'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.gallery); }),
            ListTile(leading: const Icon(Icons.camera_alt), title: const Text('Camera'), onTap: () { Navigator.pop(ctx); _pickImage(ImageSource.camera); }),
          ],
        ),
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\dev_logs_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import '../services/logger_service.dart';

class DevLogsScreen extends StatefulWidget {
  const DevLogsScreen({super.key});

  @override
  State<DevLogsScreen> createState() => _DevLogsScreenState();
}

class _DevLogsScreenState extends State<DevLogsScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text("System Logs"),
        actions: [
          IconButton(
            icon: const Icon(Icons.copy),
            onPressed: () {
              Clipboard.setData(ClipboardData(text: logger.logs.join('\n')));
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Logs copied")));
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete_sweep),
            onPressed: () => setState(() => logger.clear()),
          ),
        ],
      ),
      body: ListView.separated(
        padding: const EdgeInsets.all(16),
        itemCount: logger.logs.length,
        separatorBuilder: (_, __) => const Divider(),
        itemBuilder: (context, index) {
          final log = logger.logs[index];
          final isError = log.toLowerCase().contains('error') || log.toLowerCase().contains('exception');
          return Text(
            log,
            style: TextStyle(
              fontFamily: 'monospace',
              fontSize: 12,
              color: isError ? Colors.red : Colors.grey[800],
            ),
          );
        },
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\fast_add_screen.dart
============================================================

import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';
import 'package:path_provider/path_provider.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';
import 'package:speech_to_text/speech_to_text.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import '../providers/metadata_provider.dart'; // Using MetadataProvider for rooms/cats

class FastAddScreen extends StatefulWidget {
  const FastAddScreen({super.key});

  @override
  State<FastAddScreen> createState() => _FastAddScreenState();
}

class _FastAddScreenState extends State<FastAddScreen> with WidgetsBindingObserver {
  CameraController? _controller;
  final SpeechToText _speech = SpeechToText();
  final TextEditingController _textController = TextEditingController();

  // Track items added in this session for the "Review" modal
  final List<Item> _sessionItems = [];

  bool _isProcessing = false;
  bool _isListening = false;
  bool _voiceMode = false;
  String? _sessionRoom;
  String? _sessionCategory;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initCamera();
    _initSpeech();
  }

  Future<void> _initCamera() async {
    final cameras = await availableCameras();
    if (cameras.isNotEmpty) {
      // Use the first camera (usually back-facing)
      _controller = CameraController(
        cameras[0],
        ResolutionPreset.high,
        enableAudio: false,
        imageFormatGroup: Platform.isAndroid ? ImageFormatGroup.jpeg : ImageFormatGroup.bgra8888,
      );
      await _controller!.initialize();
      if (mounted) setState(() {});
    }
  }

  Future<void> _initSpeech() async {
    bool available = await _speech.initialize(
      onError: (val) => setState(() => _isListening = false),
      onStatus: (val) => debugPrint('Voice Status: $val'),
    );
    if (!available) {
      debugPrint("Speech recognition not available");
    }
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (_controller == null || !_controller!.value.isInitialized) return;
    if (state == AppLifecycleState.inactive) {
      _controller?.dispose();
    } else if (state == AppLifecycleState.resumed) {
      _initCamera();
    }
  }

  // --- LOGIC ---

  void _startListeningCapture() async {
    if (_isListening || !_speech.isAvailable) return;

    setState(() => _isListening = true);

    // Listen for a short burst (3 seconds max for an item name)
    await _speech.listen(
      listenFor: const Duration(seconds: 5),
      pauseFor: const Duration(seconds: 2),
      onResult: (result) {
        // Only capture if we have the final result to avoid partial captures
        if (result.finalResult) {
          setState(() => _isListening = false);
          _handleCapture(nameOverride: result.recognizedWords);
        }
      },
    );
  }

  Future<void> _handleCapture({String? nameOverride}) async {
    if (_isProcessing || _controller == null || !_controller!.value.isInitialized) return;

    setState(() => _isProcessing = true);

    try {
      final photo = await _controller!.takePicture();

      // Determine Name
      String name = nameOverride ?? _textController.text.trim();
      if (name.isEmpty) {
        // Auto-name if empty: "Item 10:30 AM"
        name = "Item ${DateFormat('jm').format(DateTime.now())}";
      }

      final savedItem = await _saveItem(photo.path, name);

      if (mounted) {
        setState(() {
          _sessionItems.insert(0, savedItem);
          _isProcessing = false;
          _textController.clear();
        });

        ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text("Added '$name'"),
              duration: const Duration(seconds: 1),
              behavior: SnackBarBehavior.floating,
            )
        );
      }
    } catch (e) {
      setState(() => _isProcessing = false);
      debugPrint("Capture Error: $e");
    }
  }

  Future<Item> _saveItem(String tempPath, String name) async {
    final appDir = await getApplicationDocumentsDirectory();
    final fileName = 'fast_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final savedFile = await File(tempPath).copy('${appDir.path}/$fileName');

    final newItem = Item(
      name: name,
      imagePaths: [savedFile.path],
      value: 0.0,
      purchaseDate: DateTime.now(),
      room: _sessionRoom,
      category: _sessionCategory,
    );

    await Provider.of<InventoryProvider>(context, listen: false).addItem(newItem);
    return newItem;
  }

  // --- REVIEW MODAL ---

  void _showReviewModal() {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.grey[900],
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(24))),
      builder: (context) => StatefulBuilder(
        builder: (context, setModalState) => DraggableScrollableSheet(
          initialChildSize: 0.7,
          maxChildSize: 0.95,
          expand: false,
          builder: (_, scrollController) => Column(
            children: [
              Container(
                margin: const EdgeInsets.symmetric(vertical: 12),
                width: 40, height: 4,
                decoration: BoxDecoration(color: Colors.white24, borderRadius: BorderRadius.circular(2)),
              ),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text("SESSION REVIEW (${_sessionItems.length})", style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold)),
                    if (_sessionItems.isNotEmpty)
                      TextButton.icon(
                        onPressed: () => _handleBatchEdit(context, setModalState),
                        icon: const Icon(Icons.edit_note, size: 18, color: Colors.blueAccent),
                        label: const Text("BATCH EDIT ROOM", style: TextStyle(color: Colors.blueAccent, fontSize: 12)),
                      ),
                  ],
                ),
              ),
              const Divider(color: Colors.white10),
              Expanded(
                child: _sessionItems.isEmpty
                    ? const Center(child: Text("No items recorded in this session.", style: TextStyle(color: Colors.white54)))
                    : GridView.builder(
                  controller: scrollController,
                  padding: const EdgeInsets.all(16),
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 3, crossAxisSpacing: 10, mainAxisSpacing: 10, childAspectRatio: 0.75,
                  ),
                  itemCount: _sessionItems.length,
                  itemBuilder: (ctx, i) => _buildGridItem(_sessionItems[i]),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _handleBatchEdit(BuildContext context, StateSetter setModalState) async {
    final metadata = Provider.of<MetadataProvider>(context, listen: false);
    String? selectedRoom = _sessionRoom;

    await showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        backgroundColor: Colors.grey[900],
        title: const Text("Batch Update Room", style: TextStyle(color: Colors.white)),
        content: DropdownButtonFormField<String>(
          value: selectedRoom,
          dropdownColor: Colors.grey[850],
          decoration: const InputDecoration(labelText: "Select Room", labelStyle: TextStyle(color: Colors.white70)),
          style: const TextStyle(color: Colors.white),
          items: metadata.rooms.map((r) => DropdownMenuItem(value: r, child: Text(r))).toList(),
          onChanged: (val) => selectedRoom = val,
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
          ElevatedButton(
            onPressed: () async {
              final invProvider = Provider.of<InventoryProvider>(context, listen: false);

              for (int i = 0; i < _sessionItems.length; i++) {
                final updatedItem = _sessionItems[i].copyWith(room: selectedRoom);
                await invProvider.updateItem(updatedItem);
                _sessionItems[i] = updatedItem;
              }

              setModalState(() {}); // Refresh Grid
              Navigator.pop(ctx);

              if(mounted) {
                ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text("Updated ${_sessionItems.length} items")));
              }
            },
            child: const Text("APPLY"),
          ),
        ],
      ),
    );
  }

  Widget _buildGridItem(Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          child: ClipRRect(
            borderRadius: BorderRadius.circular(8),
            child: Stack(
              fit: StackFit.expand,
              children: [
                Image.file(File(item.imagePaths[0]), fit: BoxFit.cover),
                Positioned(
                  bottom: 0, left: 0, right: 0,
                  child: Container(
                    color: Colors.black54,
                    padding: const EdgeInsets.all(2),
                    child: Text(item.room ?? "No Room", textAlign: TextAlign.center, style: const TextStyle(color: Colors.white, fontSize: 8)),
                  ),
                )
              ],
            ),
          ),
        ),
        const SizedBox(height: 4),
        Text(item.name, maxLines: 1, overflow: TextOverflow.ellipsis, style: const TextStyle(color: Colors.white70, fontSize: 10)),
      ],
    );
  }

  // --- MAIN UI ---

  @override
  Widget build(BuildContext context) {
    if (_controller == null || !_controller!.value.isInitialized) {
      return const Scaffold(backgroundColor: Colors.black, body: Center(child: CircularProgressIndicator()));
    }

    // Access MetadataProvider for dropdowns
    final metadata = context.watch<MetadataProvider>();
    final bottomInset = MediaQuery.of(context).viewInsets.bottom;

    return Scaffold(
      backgroundColor: Colors.black,
      resizeToAvoidBottomInset: false,
      body: Stack(
        fit: StackFit.expand,
        children: [
          // 1. Camera Preview (Centered & Scaled)
          Center(child: CameraPreview(_controller!)),

          // 2. Top Controls
          Positioned(
            top: MediaQuery.of(context).padding.top + 10,
            left: 16, right: 16,
            child: _buildSessionBar(metadata),
          ),

          // 3. Mode Toggle
          Positioned(
            top: MediaQuery.of(context).padding.top + 80,
            right: 16,
            child: Column(
              children: [
                _buildModeToggle(),
                const SizedBox(height: 10),
                const Text("Voice Mode", style: TextStyle(color: Colors.white, fontSize: 10, shadows: [Shadow(blurRadius: 4, color: Colors.black)]))
              ],
            ),
          ),

          // 4. Bottom Controls
          Positioned(
            bottom: bottomInset > 0 ? bottomInset + 10 : 30,
            left: 0, right: 0,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                _voiceMode ? _buildVoiceIndicator() : _buildTextInput(),
                const SizedBox(height: 20),
                _buildActionRow(),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildModeToggle() {
    return FloatingActionButton.small(
      heroTag: "modeSwitch",
      backgroundColor: _voiceMode ? Colors.blueAccent : Colors.grey[800],
      onPressed: () => setState(() => _voiceMode = !_voiceMode),
      child: Icon(_voiceMode ? Icons.mic : Icons.keyboard, color: Colors.white),
    );
  }

  Widget _buildSessionBar(MetadataProvider metadata) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(color: Colors.black54, borderRadius: BorderRadius.circular(16)),
      child: Row(
        children: [
          IconButton(icon: const Icon(Icons.close, color: Colors.white), onPressed: () => Navigator.pop(context)),
          Expanded(child: _buildCompactDropdown("Room", _sessionRoom, metadata.rooms, (val) => setState(() => _sessionRoom = val))),
          const SizedBox(width: 8),
          Expanded(child: _buildCompactDropdown("Cat.", _sessionCategory, metadata.categories, (val) => setState(() => _sessionCategory = val))),
        ],
      ),
    );
  }

  Widget _buildTextInput() {
    return SizedBox(
      width: 280,
      child: TextField(
        controller: _textController,
        textAlign: TextAlign.center,
        style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
        decoration: InputDecoration(
          hintText: "Item Name (Optional)",
          hintStyle: const TextStyle(color: Colors.white54),
          filled: true,
          fillColor: Colors.black45,
          contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(30), borderSide: BorderSide.none),
        ),
      ),
    );
  }

  Widget _buildVoiceIndicator() {
    return Column(
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 300),
          height: 50, width: 50,
          decoration: BoxDecoration(
              color: _isListening ? Colors.redAccent : Colors.black45,
              shape: BoxShape.circle,
              border: _isListening ? Border.all(color: Colors.white, width: 2) : null
          ),
          child: Icon(_isListening ? Icons.graphic_eq : Icons.mic_none, color: Colors.white),
        ),
        const SizedBox(height: 8),
        Text(
          _isListening ? "Listening..." : "Tap Camera to Speak",
          style: const TextStyle(color: Colors.white, shadows: [Shadow(blurRadius: 4, color: Colors.black)]),
        ),
      ],
    );
  }

  Widget _buildActionRow() {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceEvenly,
      children: [
        _buildBottomBtn(Icons.grid_view, "REVIEW", _showReviewModal, badge: _sessionItems.length),

        // Shutter Button
        GestureDetector(
          onTap: _voiceMode ? _startListeningCapture : _handleCapture,
          child: Container(
            height: 80, width: 80,
            decoration: BoxDecoration(shape: BoxShape.circle, border: Border.all(color: Colors.white, width: 4)),
            child: Center(
              child: Container(
                height: 64, width: 64,
                decoration: const BoxDecoration(color: Colors.white, shape: BoxShape.circle),
                child: _isProcessing
                    ? const Padding(padding: EdgeInsets.all(18), child: CircularProgressIndicator(color: Colors.black, strokeWidth: 2))
                    : Icon(_voiceMode ? Icons.mic : Icons.camera_alt, size: 30, color: Colors.black),
              ),
            ),
          ),
        ),

        _buildBottomBtn(Icons.check, "DONE", () => Navigator.pop(context)),
      ],
    );
  }

  Widget _buildBottomBtn(IconData icon, String label, VoidCallback onTap, {int badge = 0}) {
    return GestureDetector(
      onTap: onTap,
      child: Column(
        children: [
          Stack(
            clipBehavior: Clip.none,
            children: [
              Container(
                padding: const EdgeInsets.all(12),
                decoration: const BoxDecoration(color: Colors.black45, shape: BoxShape.circle),
                child: Icon(icon, color: Colors.white, size: 24),
              ),
              if (badge > 0)
                Positioned(right: 0, top: 0, child: Container(padding: const EdgeInsets.all(4), decoration: const BoxDecoration(color: Colors.blue, shape: BoxShape.circle), child: Text("$badge", style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)))),
            ],
          ),
          const SizedBox(height: 4),
          Text(label, style: const TextStyle(color: Colors.white, fontSize: 10, fontWeight: FontWeight.bold)),
        ],
      ),
    );
  }

  Widget _buildCompactDropdown(String hint, String? value, List<String> items, Function(String?) onChanged) {
    return DropdownButtonHideUnderline(
      child: DropdownButton<String>(
        value: items.contains(value) ? value : null,
        hint: Text(hint, style: const TextStyle(color: Colors.white54, fontSize: 12)),
        dropdownColor: Colors.black87,
        icon: const Icon(Icons.expand_more, color: Colors.white54, size: 16),
        style: const TextStyle(color: Colors.white, fontSize: 12),
        isExpanded: true,
        items: items.map((e) => DropdownMenuItem(value: e, child: Text(e))).toList(),
        onChanged: onChanged,
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _controller?.dispose();
    _speech.stop();
    _textController.dispose();
    super.dispose();
  }
}

============================================================
PATH: .\lib\screens\home_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:provider/provider.dart';
import 'package:intl/intl.dart';

import '../providers/inventory_provider.dart';
import '../providers/settings_provider.dart';
import '../services/pdf_service.dart';
import '../services/zip_service.dart';
import '../services/export_service.dart';
import '../models/item.dart';

// Screens
import 'add_item_screen.dart';
import 'item_detail_screen.dart';
import 'settings_screen.dart';
import 'fast_add_screen.dart';
import '../widgets/barcode_scanner.dart'; // Assumed existing widget

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  final ScrollController _scrollController = ScrollController();
  final TextEditingController _searchController = TextEditingController();

  bool _isSearching = false;
  bool _showActions = true;

  // --- SELECTION STATE ---
  final Set<int> _selectedIds = {};
  bool get _isSelectionMode => _selectedIds.isNotEmpty;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    _searchController.dispose();
    super.dispose();
  }

  /// Combined Scroll Logic:
  /// 1. Hides/Shows the Action Dock based on direction.
  /// 2. Triggers Pagination when near bottom.
  void _onScroll() {
    // 1. Action Dock Visibility
    if (_scrollController.position.userScrollDirection == ScrollDirection.reverse) {
      if (_showActions) setState(() => _showActions = false);
    } else if (_scrollController.position.userScrollDirection == ScrollDirection.forward) {
      if (!_showActions) setState(() => _showActions = true);
    }

    // 2. Pagination (Load More)
    // Trigger when user is 200 pixels from the bottom
    if (_scrollController.position.pixels >= _scrollController.position.maxScrollExtent - 200) {
      context.read<InventoryProvider>().loadNextPage();
    }
  }

  // --- SELECTION HELPERS ---

  void _toggleSelection(int id) {
    setState(() {
      if (_selectedIds.contains(id)) {
        _selectedIds.remove(id);
      } else {
        _selectedIds.add(id);
      }
    });
  }

  void _clearSelection() {
    setState(() => _selectedIds.clear());
  }

  Future<void> _confirmBatchDelete() async {
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    final count = _selectedIds.length;

    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text("Delete $count items?"),
        content: const Text("This will permanently remove these items and all associated photos."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("CANCEL")),
          TextButton(
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("DELETE", style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold)),
          ),
        ],
      ),
    );

    if (confirm == true) {
      // Create a copy of ids to iterate safely
      final idsToDelete = List<int>.from(_selectedIds);
      for (var id in idsToDelete) {
        await provider.deleteItem(id);
      }
      _clearSelection();
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text("Successfully deleted $count items")),
        );
      }
    }
  }

  // --- SMART SEARCH HIGHLIGHTER ---

  Widget _buildHighlightedText(String fullText, String query, TextStyle baseStyle) {
    if (query.isEmpty || !fullText.toLowerCase().contains(query.toLowerCase())) {
      return Text(fullText, style: baseStyle, overflow: TextOverflow.ellipsis);
    }

    final String searchLower = query.toLowerCase();
    final String textLower = fullText.toLowerCase();
    final List<TextSpan> spans = [];

    int start = 0;
    int indexOfMatch;

    while ((indexOfMatch = textLower.indexOf(searchLower, start)) != -1) {
      if (indexOfMatch > start) {
        spans.add(TextSpan(text: fullText.substring(start, indexOfMatch)));
      }

      spans.add(TextSpan(
        text: fullText.substring(indexOfMatch, indexOfMatch + query.length),
        style: TextStyle(
          backgroundColor: Colors.yellow.withOpacity(0.5),
          color: Colors.black,
          fontWeight: FontWeight.bold,
        ),
      ));

      start = indexOfMatch + query.length;
    }

    if (start < fullText.length) {
      spans.add(TextSpan(text: fullText.substring(start)));
    }

    return RichText(
      overflow: TextOverflow.ellipsis,
      text: TextSpan(style: baseStyle, children: spans),
    );
  }

  // --- EXPORT MENU ---

  void _showExportMenu(BuildContext context) {
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    final settings = Provider.of<SettingsProvider>(context, listen: false);

    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(borderRadius: BorderRadius.vertical(top: Radius.circular(20))),
      builder: (ctx) => SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 20),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text("Export Inventory", style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              const SizedBox(height: 15),
              _buildExportTile(ctx, "Insurance PDF Report", Icons.picture_as_pdf, const Color(0xFFB71C1C),
                      () => PdfService.generateInventoryReport(provider.items, settings)),
              _buildExportTile(ctx, "CSV Spreadsheet", Icons.table_chart, const Color(0xFF2E7D32),
                      () => ExportService.shareAsCsv(provider.items)),
              _buildExportTile(ctx, "Full ZIP Backup", Icons.folder_zip, const Color(0xFF455A64), () {
                final allImages = provider.items.expand((item) => item.imagePaths).toList();
                ZipService.createFullBackup(allImages);
              }),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildExportTile(BuildContext context, String title, IconData icon, Color color, VoidCallback onTap) {
    return ListTile(
      leading: CircleAvatar(backgroundColor: color, child: Icon(icon, color: Colors.white, size: 20)),
      title: Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
      onTap: () {
        Navigator.pop(context);
        onTap();
      },
    );
  }

  // --- APP BAR BUILDER ---

  PreferredSizeWidget _buildAppBar(InventoryProvider provider, ThemeData theme) {
    if (_isSelectionMode) {
      return AppBar(
        backgroundColor: theme.colorScheme.secondaryContainer,
        leading: IconButton(icon: const Icon(Icons.close), onPressed: _clearSelection),
        title: Text("${_selectedIds.length} Selected",
            style: TextStyle(color: theme.colorScheme.onSecondaryContainer, fontWeight: FontWeight.bold)),
        actions: [
          IconButton(icon: const Icon(Icons.delete_outline), onPressed: _confirmBatchDelete),
        ],
      );
    }

    return AppBar(
      elevation: 0,
      title: _isSearching
          ? Container(
        height: 40,
        decoration: BoxDecoration(
          color: theme.colorScheme.surfaceVariant.withOpacity(0.5),
          borderRadius: BorderRadius.circular(8),
        ),
        child: TextField(
          controller: _searchController,
          autofocus: true,
          style: const TextStyle(fontSize: 16),
          decoration: const InputDecoration(
            hintText: 'Search...',
            border: InputBorder.none,
            prefixIcon: Icon(Icons.search, size: 20),
            contentPadding: EdgeInsets.symmetric(vertical: 10),
          ),
          onChanged: (val) => provider.setSearchQuery(val),
        ),
      )
          : const Text('My Inventory', style: TextStyle(fontWeight: FontWeight.bold)),
      actions: [
        IconButton(
          icon: Icon(_isSearching ? Icons.close : Icons.search),
          onPressed: () {
            setState(() {
              _isSearching = !_isSearching;
              if (!_isSearching) {
                _searchController.clear();
                provider.setSearchQuery('');
              }
            });
          },
        ),
        if (!_isSearching) ...[
          IconButton(
            icon: const Icon(Icons.qr_code_scanner_rounded),
            tooltip: 'Scan Barcode',
            onPressed: () async {
              // Ensure you have a BarcodeScannerWidget or similar logic
              final String? code = await Navigator.of(context).push(
                MaterialPageRoute(builder: (_) => const BarcodeScannerWidget()),
              );
              if (code != null && mounted) {
                setState(() {
                  _isSearching = true;
                  _searchController.text = code;
                });
                provider.setSearchQuery(code);
              }
            },
          ),
          PopupMenuButton<SortOption>(
            icon: const Icon(Icons.sort_rounded),
            onSelected: (option) => provider.setSort(option),
            itemBuilder: (context) => [
              const PopupMenuItem(value: SortOption.name, child: Text("Sort by Name")),
              const PopupMenuItem(value: SortOption.value, child: Text("Sort by Value")),
              const PopupMenuItem(value: SortOption.date, child: Text("Sort by Date")),
            ],
          ),
          IconButton(icon: const Icon(Icons.ios_share), onPressed: () => _showExportMenu(context)),
          IconButton(
            icon: const Icon(Icons.settings_outlined),
            onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (context) => const SettingsScreen())),
          ),
        ],
      ],
    );
  }

  // --- MAIN BUILD ---

  @override
  Widget build(BuildContext context) {
    final provider = context.watch<InventoryProvider>();
    final theme = Theme.of(context);

    // Initial Loading State (First load only)
    if (provider.isLoading && provider.items.isEmpty) {
      return Scaffold(
        appBar: _buildAppBar(provider, theme),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: _buildAppBar(provider, theme),
      body: Stack(
        children: [
          Column(
            children: [
              if (!_isSearching && provider.items.isNotEmpty && !_isSelectionMode)
                _buildTotalValueBanner(theme, provider.totalValue),
              Expanded(
                child: _buildUnifiedItemList(provider, theme),
              ),
            ],
          ),
          if (!_isSelectionMode) _buildActionDock(theme),
        ],
      ),
    );
  }

  Widget _buildTotalValueBanner(ThemeData theme, double total) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 20),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor, width: 0.5)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text("ESTIMATED TOTAL ASSETS",
              style: TextStyle(fontSize: 11, fontWeight: FontWeight.w600, color: Colors.grey[600], letterSpacing: 0.5)),
          Text(
            NumberFormat.simpleCurrency().format(total),
            style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.primary, fontSize: 16),
          ),
        ],
      ),
    );
  }

  Widget _buildUnifiedItemList(InventoryProvider provider, ThemeData theme) {
    final displayItems = provider.items;
    final query = provider.searchQuery.toLowerCase();

    if (displayItems.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.inventory_2_outlined, size: 64, color: Colors.grey[300]),
            const SizedBox(height: 16),
            Text(_isSearching ? 'No matches found.' : 'Inventory is empty.', style: const TextStyle(color: Colors.grey)),
            if(!_isSearching)
              Padding(
                padding: const EdgeInsets.only(top: 20),
                child: ElevatedButton.icon(
                  onPressed: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const FastAddScreen())),
                  label: const Text("Start Scanning"),
                  icon: const Icon(Icons.camera_alt),
                ),
              )
          ],
        ),
      );
    }

    // RefreshIndicator wraps the List
    return RefreshIndicator(
      onRefresh: () => provider.initializeData(),
      child: ListView.builder(
        controller: _scrollController,
        // Count = SortHeader + Items + (BottomSpinner if loading more)
        itemCount: 1 + displayItems.length + (provider.isLoadingMore ? 1 : 0),
        // Extra padding at bottom to clear the Action Dock
        padding: EdgeInsets.fromLTRB(0, 8, 0, _isSelectionMode ? 20 : 120),
        itemBuilder: (context, index) {

          // 0. Sort Label Header
          if (index == 0) {
            String sortText = "Sorted by Name";
            if (provider.currentSort == SortOption.value) sortText = "Sorted by Highest Value";
            if (provider.currentSort == SortOption.date) sortText = "Sorted by Newest First";
            return Padding(
              padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 8),
              child: Text(sortText.toUpperCase(),
                  style: TextStyle(fontSize: 10, fontWeight: FontWeight.bold, color: Colors.grey[500], letterSpacing: 1.0)),
            );
          }

          // 2. Bottom Spinner (if triggered)
          if (index == displayItems.length + 1) {
            return const Padding(
              padding: EdgeInsets.all(20),
              child: Center(child: CircularProgressIndicator()),
            );
          }

          // 1. Inventory Items
          final itemIndex = index - 1; // Adjust for header
          final item = displayItems[itemIndex];

          return _buildItemRow(item, theme, query, provider);
        },
      ),
    );
  }

  Widget _buildItemRow(Item item, ThemeData theme, String query, InventoryProvider provider) {
    final bool incomplete = item.value == 0 || item.room == null;
    final isSelected = _selectedIds.contains(item.id);

    // Dynamic Subtitle based on search match
    String subtitleText = "${item.room ?? 'Unassigned'}  ${item.category ?? 'General'}";
    if (query.isNotEmpty) {
      if (item.brand?.toLowerCase().contains(query) ?? false) {
        subtitleText = "Brand: ${item.brand}  $subtitleText";
      } else if (item.model?.toLowerCase().contains(query) ?? false) {
        subtitleText = "Model: ${item.model}  $subtitleText";
      } else if (item.serialNumber?.toLowerCase().contains(query) ?? false) {
        subtitleText = "S/N: ${item.serialNumber}  $subtitleText";
      }
    }

    return Column(
      children: [
        AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          color: isSelected ? theme.colorScheme.primaryContainer.withOpacity(0.3) : Colors.transparent,
          child: ListTile(
            contentPadding: const EdgeInsets.symmetric(horizontal: 20, vertical: 4),
            onLongPress: () => _toggleSelection(item.id!),
            onTap: () {
              if (_isSelectionMode) {
                _toggleSelection(item.id!);
              } else {
                // Pass full Item object if supported, otherwise just ID
                Navigator.of(context).push(MaterialPageRoute(builder: (context) => ItemDetailScreen(item: item, itemId: null,)));
              }
            },
            leading: Stack(
              children: [
                Container(
                  width: 54, height: 54,
                  decoration: BoxDecoration(
                    borderRadius: BorderRadius.circular(12),
                    color: theme.colorScheme.surfaceVariant,
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: _buildItemThumbnail(item),
                  ),
                ),
                if (isSelected)
                  Positioned.fill(
                    child: Container(
                      decoration: BoxDecoration(
                        borderRadius: BorderRadius.circular(12),
                        color: theme.colorScheme.primary.withOpacity(0.4),
                      ),
                      child: const Icon(Icons.check, color: Colors.white),
                    ),
                  ),
              ],
            ),
            title: _buildHighlightedText(
                item.name,
                provider.searchQuery,
                TextStyle(fontWeight: FontWeight.w600, fontSize: 15, color: theme.colorScheme.onSurface)
            ),
            subtitle: Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Row(
                children: [
                  Expanded(
                    child: _buildHighlightedText(
                      subtitleText,
                      provider.searchQuery,
                      TextStyle(fontSize: 12, color: Colors.grey[600]),
                    ),
                  ),
                  if (incomplete) _buildIncompleteBadge(),
                ],
              ),
            ),
            trailing: _isSelectionMode
                ? Checkbox(
              value: isSelected,
              onChanged: (_) => _toggleSelection(item.id!),
              shape: const CircleBorder(),
            )
                : Text(
              NumberFormat.simpleCurrency(decimalDigits: 0).format(item.value),
              style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.primary),
            ),
          ),
        ),
        const Divider(height: 1, indent: 86),
      ],
    );
  }

  Widget _buildItemThumbnail(Item item) {
    if (item.imagePaths.isNotEmpty) {
      final file = File(item.imagePaths[0]);
      if (file.existsSync()) {
        return Image.file(file, fit: BoxFit.cover, errorBuilder: (c,e,s) => const Icon(Icons.broken_image, color: Colors.grey));
      }
    }
    return const Icon(Icons.image_outlined, color: Colors.grey);
  }

  Widget _buildActionDock(ThemeData theme) {
    return AnimatedPositioned(
      duration: const Duration(milliseconds: 350),
      curve: Curves.easeOutCubic,
      bottom: _showActions ? 0 : -140,
      left: 0,
      right: 0,
      child: Container(
        padding: const EdgeInsets.fromLTRB(20, 16, 20, 36),
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.vertical(top: Radius.circular(28)),
          boxShadow: [
            BoxShadow(color: Colors.black.withOpacity(0.08), blurRadius: 20, offset: const Offset(0, -5)),
          ],
        ),
        child: Row(
          children: [
            Expanded(
              flex: 2,
              child: InkWell(
                onTap: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const FastAddScreen())),
                child: Container(
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant, borderRadius: BorderRadius.circular(16)),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(Icons.bolt_rounded, size: 20, color: theme.colorScheme.onSurfaceVariant),
                      const SizedBox(width: 8),
                      Text("FAST ADD", style: TextStyle(fontWeight: FontWeight.bold, color: theme.colorScheme.onSurfaceVariant, letterSpacing: 0.5)),
                    ],
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              flex: 3,
              child: ElevatedButton.icon(
                onPressed: () => Navigator.of(context).push(MaterialPageRoute(builder: (_) => const AddItemScreen())),
                style: ElevatedButton.styleFrom(
                  backgroundColor: theme.colorScheme.primary,
                  foregroundColor: theme.colorScheme.onPrimary,
                  padding: const EdgeInsets.symmetric(vertical: 16),
                  elevation: 0,
                  shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
                ),
                icon: const Icon(Icons.add_rounded),
                label: const Text("FULL ENTRY", style: TextStyle(fontWeight: FontWeight.bold, letterSpacing: 0.5)),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildIncompleteBadge() {
    return Container(
      margin: const EdgeInsets.only(left: 8),
      padding: const EdgeInsets.symmetric(horizontal: 5, vertical: 1),
      decoration: BoxDecoration(
        color: Colors.orange.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
        border: Border.all(color: Colors.orange.withOpacity(0.3)),
      ),
      child: const Text("!", style: TextStyle(color: Colors.orange, fontSize: 10, fontWeight: FontWeight.bold)),
    );
  }
}

============================================================
PATH: .\lib\screens\item_detail_screen.dart
============================================================

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // For Clipboard
import 'package:intl/intl.dart';
import 'package:provider/provider.dart';
import '../models/item.dart';
import '../providers/inventory_provider.dart';
import 'add_item_screen.dart';

class ItemDetailScreen extends StatefulWidget {
  final int? itemId;
  final Item? item; // Optimization: Pass object for instant load

  const ItemDetailScreen({
    super.key,
    this.itemId,
    this.item,
  });

  @override
  State<ItemDetailScreen> createState() => _ItemDetailScreenState();
}

class _ItemDetailScreenState extends State<ItemDetailScreen> {
  late Item _item;
  bool _isLoading = true;
  bool _isDeleted = false;

  @override
  void initState() {
    super.initState();
    _initializeItem();
  }

  void _initializeItem() {
    // 1. Instant Load: Use passed object if available
    if (widget.item != null) {
      _item = widget.item!;
      _isLoading = false;
      return;
    }

    // 2. Fallback: Fetch from Provider using ID
    if (widget.itemId != null) {
      final provider = Provider.of<InventoryProvider>(context, listen: false);
      try {
        _item = provider.items.firstWhere((i) => i.id == widget.itemId);
        _isLoading = false;
      } catch (e) {
        // Item not found (likely deleted)
        _isDeleted = true;
        _isLoading = false;
      }
    } else {
      _isDeleted = true;
      _isLoading = false;
    }
  }

  /// Reloads item data from Provider (useful after Editing)
  void _refreshItem() {
    if (_isDeleted) return;
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    try {
      final freshItem = provider.items.firstWhere((i) => i.id == _item.id);
      setState(() {
        _item = freshItem;
      });
    } catch (e) {
      setState(() => _isDeleted = true);
    }
  }

  Future<void> _confirmDelete() async {
    final provider = Provider.of<InventoryProvider>(context, listen: false);

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Delete Item?"),
        content: Text("This will permanently remove '${_item.name}' from your inventory."),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text("CANCEL")),
          FilledButton(
            style: FilledButton.styleFrom(backgroundColor: Colors.red),
            onPressed: () => Navigator.pop(ctx, true),
            child: const Text("DELETE"),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      await provider.deleteItem(_item.id!);
      if (mounted) Navigator.pop(context);
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) return const Scaffold(body: Center(child: CircularProgressIndicator()));
    if (_isDeleted) return const Scaffold(body: Center(child: Text("Item no longer exists.")));

    // Watch for external updates (e.g. background sync or batch delete)
    final provider = context.watch<InventoryProvider>();
    try {
      // Sync local item with provider state if possible
      _item = provider.items.firstWhere((i) => i.id == _item.id, orElse: () => _item);
    } catch (e) {
      // If provider is empty/cleared, keep showing local copy or exit
    }

    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text("Item Details"),
        actions: [
          IconButton(
            icon: const Icon(Icons.edit_outlined),
            tooltip: 'Edit Item',
            onPressed: () async {
              await Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => AddItemScreen(itemToEdit: _item)),
              );
              _refreshItem(); // Update UI with edited values
            },
          ),
          IconButton(
            icon: const Icon(Icons.delete_outline),
            tooltip: 'Delete Item',
            onPressed: _confirmDelete,
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            _buildImageGallery(context, _item),
            Padding(
              padding: const EdgeInsets.all(20.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildHeader(theme, _item),
                  const SizedBox(height: 24),

                  // Priority Cards
                  if (_item.warrantyExpiry != null) _buildWarrantyCard(theme, _item),
                  if (_item.serialNumber != null && _item.serialNumber!.isNotEmpty)
                    _buildSerialCard(context, theme, _item.serialNumber!),

                  const Divider(height: 40),

                  // Specifics Grid
                  _buildInfoGrid(theme, _item),

                  const SizedBox(height: 24),
                  if (_item.notes != null && _item.notes!.isNotEmpty) _buildNotes(theme, _item),
                  const SizedBox(height: 40),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // --- UI COMPONENTS ---

  Widget _buildImageGallery(BuildContext context, Item item) {
    if (item.imagePaths.isEmpty) {
      return Container(
        height: 200,
        width: double.infinity,
        color: Colors.grey[200],
        child: const Icon(Icons.image_not_supported, size: 64, color: Colors.grey),
      );
    }

    return SizedBox(
      height: 320,
      child: PageView.builder(
        itemCount: item.imagePaths.length,
        itemBuilder: (context, index) {
          final path = item.imagePaths[index];
          final file = File(path);
          final bool isReceipt = item.receiptIndices.contains(index);

          return Stack(
            fit: StackFit.expand,
            children: [
              if (file.existsSync())
                Image.file(file, fit: BoxFit.cover)
              else
                Container(color: Colors.grey, child: const Icon(Icons.broken_image)),

              if (isReceipt)
                Positioned(
                  top: 16, right: 16,
                  child: Chip(
                    backgroundColor: Colors.green.withOpacity(0.9),
                    side: BorderSide.none,
                    label: const Text("RECEIPT", style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold, fontSize: 10)),
                    avatar: const Icon(Icons.receipt_long, color: Colors.white, size: 14),
                  ),
                ),

              // Page Indicator (e.g., 1/3)
              if (item.imagePaths.length > 1)
                Positioned(
                  bottom: 16, right: 16,
                  child: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                    decoration: BoxDecoration(color: Colors.black54, borderRadius: BorderRadius.circular(20)),
                    child: Text("${index + 1} / ${item.imagePaths.length}", style: const TextStyle(color: Colors.white, fontSize: 12)),
                  ),
                ),
            ],
          );
        },
      ),
    );
  }

  Widget _buildHeader(ThemeData theme, Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(item.name, style: theme.textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold)),
        const SizedBox(height: 8),
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              NumberFormat.currency(symbol: "\$").format(item.value),
              style: theme.textTheme.headlineSmall?.copyWith(color: theme.colorScheme.primary, fontWeight: FontWeight.w600),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
              decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant, borderRadius: BorderRadius.circular(20)),
              child: Text(DateFormat('MMM d, yyyy').format(item.purchaseDate), style: theme.textTheme.bodySmall),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildWarrantyCard(ThemeData theme, Item item) {
    final now = DateTime.now();
    final isExpired = item.warrantyExpiry!.isBefore(now);
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: isExpired ? Colors.red.withOpacity(0.05) : Colors.green.withOpacity(0.05),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: isExpired ? Colors.red.shade200 : Colors.green.shade200),
      ),
      child: Row(
        children: [
          Icon(isExpired ? Icons.event_busy : Icons.verified_user_outlined, color: isExpired ? Colors.red : Colors.green),
          const SizedBox(width: 12),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(isExpired ? "Warranty Expired" : "Under Warranty",
                  style: TextStyle(fontWeight: FontWeight.bold, color: isExpired ? Colors.red.shade900 : Colors.green.shade900)),
              Text("Ended: ${DateFormat('MMM d, yyyy').format(item.warrantyExpiry!)}", style: const TextStyle(fontSize: 12)),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSerialCard(BuildContext context, ThemeData theme, String serial) {
    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: theme.colorScheme.outlineVariant),
      ),
      child: Row(
        children: [
          const Icon(Icons.qr_code, size: 20, color: Colors.grey),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Serial Number", style: TextStyle(fontSize: 11, color: Colors.grey)),
                Text(serial, style: const TextStyle(fontFamily: 'monospace', fontWeight: FontWeight.w600)),
              ],
            ),
          ),
          IconButton(
            icon: const Icon(Icons.copy, size: 18),
            onPressed: () {
              Clipboard.setData(ClipboardData(text: serial));
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Serial copied to clipboard"), behavior: SnackBarBehavior.floating));
            },
          ),
        ],
      ),
    );
  }

  Widget _buildInfoGrid(ThemeData theme, Item item) {
    return Column(
      children: [
        Row(
          children: [
            Expanded(child: _buildInfoTile("Room", item.room ?? "General", Icons.room_outlined)),
            Expanded(child: _buildInfoTile("Category", item.category ?? "None", Icons.category_outlined)),
          ],
        ),
        const SizedBox(height: 20),
        Row(
          children: [
            Expanded(child: _buildInfoTile("Brand", item.brand ?? "N/A", Icons.factory_outlined)),
            Expanded(child: _buildInfoTile("Model", item.model ?? "N/A", Icons.label_important_outline)),
          ],
        ),
      ],
    );
  }

  Widget _buildInfoTile(String label, String value, IconData icon) {
    return Row(
      children: [
        Icon(icon, size: 18, color: Colors.grey),
        const SizedBox(width: 8),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(label, style: const TextStyle(fontSize: 11, color: Colors.grey)),
              Text(value, style: const TextStyle(fontWeight: FontWeight.w500, fontSize: 14), overflow: TextOverflow.ellipsis),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildNotes(ThemeData theme, Item item) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text("Notes & Description", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
        const SizedBox(height: 8),
        Container(
          width: double.infinity,
          padding: const EdgeInsets.all(12),
          decoration: BoxDecoration(color: theme.colorScheme.surfaceVariant.withOpacity(0.3), borderRadius: BorderRadius.circular(8)),
          child: Text(item.notes!, style: const TextStyle(height: 1.5)),
        ),
      ],
    );
  }
}

============================================================
PATH: .\lib\screens\list_management_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/metadata_provider.dart'; // NEW IMPORT

class ListManagementScreen extends StatelessWidget {
  final bool isRoom;
  const ListManagementScreen({super.key, required this.isRoom});

  @override
  Widget build(BuildContext context) {
    // Watch MetadataProvider instead of InventoryProvider
    final metadata = context.watch<MetadataProvider>();
    final items = isRoom ? metadata.rooms : metadata.categories;

    return Scaffold(
      appBar: AppBar(title: Text(isRoom ? 'Manage Rooms' : 'Manage Categories')),
      body: Column(
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: TextField(
              decoration: InputDecoration(
                labelText: isRoom ? 'New Room Name' : 'New Category Name',
                suffixIcon: const Icon(Icons.add),
                border: const OutlineInputBorder(),
              ),
              onSubmitted: (val) {
                if (val.trim().isNotEmpty) {
                  if (isRoom) {
                    metadata.addRoom(val);
                  } else {
                    metadata.addCategory(val);
                  }
                }
              },
            ),
          ),
          Expanded(
            child: items.isEmpty
                ? const Center(child: Text("No items found"))
                : ListView.separated(
              itemCount: items.length,
              separatorBuilder: (_, __) => const Divider(),
              itemBuilder: (context, index) {
                final item = items[index];
                return ListTile(
                  title: Text(item),
                  trailing: IconButton(
                    icon: const Icon(Icons.delete, color: Colors.red),
                    onPressed: () {
                      // Show confirmation dialog before deleting
                      showDialog(
                        context: context,
                        builder: (ctx) => AlertDialog(
                          title: const Text("Delete?"),
                          content: Text("Are you sure you want to remove '$item'? Items currently in this ${isRoom ? 'room' : 'category'} will need to be reassigned."),
                          actions: [
                            TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("CANCEL")),
                            TextButton(
                              onPressed: () {
                                if (isRoom) {
                                  metadata.removeRoom(item);
                                } else {
                                  metadata.removeCategory(item);
                                }
                                Navigator.pop(ctx);
                              },
                              child: const Text("DELETE", style: TextStyle(color: Colors.red)),
                            ),
                          ],
                        ),
                      );
                    },
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\screens\settings_screen.dart
============================================================

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'dart:io';
import 'package:file_picker/file_picker.dart';
import '../providers/inventory_provider.dart';
import '../providers/settings_provider.dart';
import '../services/zip_service.dart';
import '../services/demo_service.dart';
import 'list_management_screen.dart';
import 'dev_logs_screen.dart'; // <--- NEW IMPORT

const bool _showDebugOptions = true;

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  late TextEditingController _nameController;
  late TextEditingController _companyController;
  late TextEditingController _addressController;
  late TextEditingController _policyController;

  @override
  void initState() {
    super.initState();
    final settings = context.read<SettingsProvider>();
    _nameController = TextEditingController(text: settings.userName);
    _companyController = TextEditingController(text: settings.insuranceCompany);
    _addressController = TextEditingController(text: settings.address);
    _policyController = TextEditingController(text: settings.policyNumber);
  }

  @override
  void dispose() {
    _nameController.dispose();
    _companyController.dispose();
    _addressController.dispose();
    _policyController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final settingsProvider = context.watch<SettingsProvider>();

    return Scaffold(
      appBar: AppBar(title: const Text('Settings')),
      body: ListView(
        children: [
          _buildSectionHeader(context, 'Insurance Profile'),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
            child: Column(
              children: [
                TextField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: "Policy Holder Name",
                    prefixIcon: Icon(Icons.person_outline),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _companyController,
                  decoration: const InputDecoration(
                    labelText: "Insurance Company",
                    prefixIcon: Icon(Icons.business_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _policyController,
                  decoration: const InputDecoration(
                    labelText: "Policy Number",
                    prefixIcon: Icon(Icons.description_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _addressController,
                  maxLines: 2,
                  decoration: const InputDecoration(
                    labelText: "Property Address",
                    prefixIcon: Icon(Icons.home_outlined),
                    border: OutlineInputBorder(),
                  ),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: ElevatedButton.icon(
                    onPressed: () {
                      settingsProvider.updateProfile(
                        _nameController.text,
                        _addressController.text,
                        _policyController.text,
                        _companyController.text,
                      );
                      ScaffoldMessenger.of(context).showSnackBar(
                        const SnackBar(content: Text("Profile Saved Successfully"), behavior: SnackBarBehavior.floating),
                      );
                    },
                    icon: const Icon(Icons.save),
                    label: const Text("Save Insurance Info"),
                  ),
                ),
              ],
            ),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Appearance'),
          ListTile(
            leading: const CircleAvatar(child: Icon(Icons.palette_outlined)),
            title: const Text("Theme Mode"),
            subtitle: Text("Currently: ${settingsProvider.themeMode.name.toUpperCase()}"),
            trailing: DropdownButton<ThemeMode>(
              value: settingsProvider.themeMode,
              onChanged: (ThemeMode? newMode) {
                if (newMode != null) settingsProvider.setThemeMode(newMode);
              },
              items: const [
                DropdownMenuItem(value: ThemeMode.system, child: Text("System")),
                DropdownMenuItem(value: ThemeMode.light, child: Text("Light")),
                DropdownMenuItem(value: ThemeMode.dark, child: Text("Dark")),
              ],
            ),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Data Management'),
          _buildTile(
            context,
            icon: Icons.cloud_upload_outlined,
            color: Colors.blue,
            title: 'Export Backup',
            subtitle: 'Create a .zip file with all data and photos',
            onTap: () async {
              final provider = Provider.of<InventoryProvider>(context, listen: false);
              final allImages = provider.items.expand((item) => item.imagePaths).toList();
              File? zip = await ZipService.createFullBackup(allImages);
              if (zip != null && context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Backup created at: ${zip.path}')));
              }
            },
          ),
          _buildTile(
            context,
            icon: Icons.file_download_outlined,
            color: Colors.orange,
            title: 'Import Backup',
            subtitle: 'Restore inventory from another device',
            onTap: () => _handleImport(context),
          ),

          const Divider(),
          _buildSectionHeader(context, 'Organization'),
          _buildTile(
            context,
            icon: Icons.meeting_room_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Rooms',
            subtitle: 'Add or remove locations in your home',
            onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: true))),
          ),
          _buildTile(
            context,
            icon: Icons.style_outlined,
            color: theme.colorScheme.primary,
            title: 'Manage Categories',
            subtitle: 'Define item types (Electronics, Tools, etc.)',
            onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const ListManagementScreen(isRoom: false))),
          ),

          if (_showDebugOptions) ...[
            const Divider(),
            _buildSectionHeader(context, 'Developer Tools'),
            // --- NEW: LOG VIEWER TILE ---
            _buildTile(
              context,
              icon: Icons.bug_report_outlined,
              color: Colors.teal,
              title: 'System Logs',
              subtitle: 'View recent scan events and errors',
              onTap: () => Navigator.push(context, MaterialPageRoute(builder: (_) => const DevLogsScreen())),
            ),
            _buildTile(
              context,
              icon: Icons.auto_fix_high,
              color: Colors.purple,
              title: 'Load Demo Data',
              subtitle: 'Add sample items to test PDF and UI',
              onTap: () async {
                final provider = context.read<InventoryProvider>();
                await DemoService.populateDemoData(provider);
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Demo data loaded!")));
                }
              },
            ),
            _buildTile(
              context,
              icon: Icons.delete_forever,
              color: Colors.red,
              title: 'Clear All Data',
              subtitle: 'Danger: Wipe entire inventory',
              onTap: () => _confirmClearAll(context),
            ),
          ],
          const SizedBox(height: 30),
        ],
      ),
    );
  }

  // --- HELPER METHODS (Unchanged from your snippet) ---
  Widget _buildSectionHeader(BuildContext context, String title) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 20, 16, 8),
      child: Text(
        title.toUpperCase(),
        style: TextStyle(fontSize: 12, fontWeight: FontWeight.bold, color: Theme.of(context).colorScheme.secondary, letterSpacing: 1.1),
      ),
    );
  }

  Widget _buildTile(BuildContext context, {required IconData icon, required Color color, required String title, required String subtitle, required VoidCallback onTap}) {
    return ListTile(
      leading: CircleAvatar(backgroundColor: color.withOpacity(0.1), child: Icon(icon, color: color)),
      title: Text(title, style: const TextStyle(fontWeight: FontWeight.w500)),
      subtitle: Text(subtitle, style: const TextStyle(fontSize: 12)),
      trailing: const Icon(Icons.chevron_right, size: 20),
      onTap: onTap,
    );
  }

  void _confirmClearAll(BuildContext context) {
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Wipe All Data?'),
        content: const Text('This will permanently delete your entire inventory. This action cannot be undone.'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('CANCEL')),
          TextButton(
            onPressed: () {
              context.read<InventoryProvider>().clearAll();
              Navigator.pop(ctx);
              ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text("Inventory cleared.")));
            },
            child: const Text('CLEAR ALL', style: TextStyle(color: Colors.red)),
          ),
        ],
      ),
    );
  }

  Future<void> _handleImport(BuildContext context) async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(type: FileType.custom, allowedExtensions: ['zip']);
    if (result == null) return;
    final provider = Provider.of<InventoryProvider>(context, listen: false);
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Restore Data?'),
        content: const Text('This will overwrite your current inventory. Continue?'),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text('CANCEL')),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(ctx);
              bool success = await ZipService.importBackup(File(result.files.single.path!));
              if (success) {
                await provider.refreshAfterImport();
              }
            },
            child: const Text('RESTORE'),
          ),
        ],
      ),
    );
  }
}

============================================================
PATH: .\lib\services\backup_service.dart
============================================================

import 'dart:io';
import 'dart:convert';
import 'package:archive/archive.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../providers/inventory_provider.dart';
import '../services/logger_service.dart'; // Import your logger

class BackupService {
  static Future<void> createAndShareBackup(BuildContext context) async {
    logger.log("--- Starting Backup Process ---");

    try {
      // 1. Fetch current items from the Provider
      final items = Provider.of<InventoryProvider>(context, listen: false).items;

      if (items.isEmpty) {
        logger.log("Backup Aborted: Inventory list is empty.");
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('No items to export!')),
        );
        return;
      }

      logger.log("Exporting ${items.length} items to ZIP...");
      final archive = Archive();

      // 2. Create the JSON data file
      final List<Map<String, dynamic>> jsonData = items.map((i) => i.toMap()).toList();
      final String jsonString = jsonEncode(jsonData);
      final List<int> jsonBytes = utf8.encode(jsonString);
      archive.addFile(ArchiveFile('inventory_data.json', jsonBytes.length, jsonBytes));
      logger.log("Added inventory_data.json to archive.");

      // 3. Add ALL images to the ZIP
      int imageCount = 0;
      int missingFiles = 0;

      for (var item in items) {
        for (var imagePath in item.imagePaths) {
          final imageFile = File(imagePath);
          if (await imageFile.exists()) {
            final fileName = path.basename(imagePath);
            final bytes = await imageFile.readAsBytes();
            archive.addFile(ArchiveFile('images/$fileName', bytes.length, bytes));
            imageCount++;
          } else {
            missingFiles++;
            logger.log("Warning: Image not found at $imagePath (Item: ${item.name})");
          }
        }
      }
      logger.log("Added $imageCount images to archive. ($missingFiles files were missing from storage).");

      // 4. Save the ZIP file to temporary storage
      logger.log("Encoding ZIP file...");
      final zipEncoder = ZipEncoder();
      final List<int>? zipBytes = zipEncoder.encode(archive);

      if (zipBytes == null) {
        logger.log("Error: ZIP encoding failed (Returned null).");
        return;
      }

      final tempDir = await getTemporaryDirectory();
      final zipFile = File('${tempDir.path}/Home_Inventory_Backup.zip');
      await zipFile.writeAsBytes(zipBytes);

      final fileSizeMB = (await zipFile.length() / (1024 * 1024)).toStringAsFixed(2);
      logger.log("ZIP created successfully at ${zipFile.path} (Size: $fileSizeMB MB)");

      // 5. Trigger the Share Sheet
      logger.log("Opening Share Sheet...");
      final xFile = XFile(zipFile.path);
      await Share.shareXFiles(
        [xFile],
        text: 'My Home Inventory Backup (Insurance Data)',
      );
      logger.log("Backup process completed successfully.");

    } catch (e) {
      logger.log("CRITICAL BACKUP ERROR", error: e);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Backup failed: $e')),
        );
      }
    }
  }
}

============================================================
PATH: .\lib\services\demo_service.dart
============================================================

import '../models/item.dart';
import '../providers/inventory_provider.dart';

class DemoService {
  static Future<void> populateDemoData(InventoryProvider provider) async {
    final List<Item> demoItems = [
      Item(
        name: "MacBook Pro 16",
        brand: "Apple",
        model: "M3 Max",
        serialNumber: "SN-DEMO-9921",
        value: 2499.00,
        room: "Office",
        category: "Electronics",
        purchaseDate: DateTime.now().subtract(const Duration(days: 200)),
        warrantyExpiry: DateTime.now().add(const Duration(days: 165)),
        notes: "Primary work machine. Includes power adapter and leather sleeve.",
        imagePaths: [], // Note: Photos won't appear unless you manually add local asset paths
      ),
      Item(
        name: "Sony 65\" OLED TV",
        brand: "Sony",
        model: "A80J",
        serialNumber: "SN-TV-55123",
        value: 1800.00,
        room: "Living Room",
        category: "Electronics",
        purchaseDate: DateTime.now().subtract(const Duration(days: 400)),
        warrantyExpiry: DateTime.now().subtract(const Duration(days: 35)), // Expired
        notes: "Mounted on wall bracket.",
        imagePaths: [],
      ),
      Item(
        name: "Engagement Ring",
        brand: "Tiffany & Co.",
        model: "Setting Platinum",
        value: 8500.00,
        room: "Bedroom",
        category: "Jewelry",
        purchaseDate: DateTime.now().subtract(const Duration(days: 1000)),
        notes: "High value - check specific insurance rider.",
        imagePaths: [],
      ),
      Item(
        name: "Coffee Table",
        brand: "West Elm",
        model: "Mid-Century Modern",
        value: 450.00,
        room: "Living Room",
        category: "Furniture",
        purchaseDate: DateTime.now().subtract(const Duration(days: 60)),
        imagePaths: [],
      ),
    ];

    for (var item in demoItems) {
      await provider.addItem(item);
    }
  }
}

============================================================
PATH: .\lib\services\export_service.dart
============================================================

import 'dart:convert';
import 'dart:io';
import 'package:csv/csv.dart';
import 'package:path_provider/path_provider.dart';
import 'package:share_plus/share_plus.dart';
import '../models/item.dart';
import '../services/logger_service.dart'; // Import your logger

class ExportService {
  static Future<void> shareAsJson(List<Item> items) async {
    logger.log("Export: Starting JSON generation for ${items.length} items...");

    try {
      final jsonData = items.map((i) => i.toMap()).toList();
      final directory = await getTemporaryDirectory();
      final file = File('${directory.path}/inventory_export.json');

      await file.writeAsString(jsonEncode(jsonData));

      final fileSize = await file.length();
      logger.log("Export: JSON file written (${fileSize} bytes). Opening share sheet.");

      await Share.shareXFiles([XFile(file.path)], text: 'Inventory JSON Backup');
      logger.log("Export: JSON Share sheet closed.");
    } catch (e) {
      logger.log("EXPORT ERROR (JSON)", error: e);
      rethrow;
    }
  }

  static Future<void> shareAsCsv(List<Item> items) async {
    logger.log("Export: Starting CSV generation for ${items.length} items...");

    try {
      List<List<dynamic>> rows = [
        ["Name", "Value", "Room", "Category", "Purchase Date", "Brand", "Model", "Serial", "Notes"]
      ];

      for (var i in items) {
        rows.add([
          i.name,
          i.value,
          i.room ?? "",
          i.category ?? "",
          i.purchaseDate.toIso8601String(),
          i.brand ?? "",
          i.model ?? "",
          i.serialNumber ?? "",
          i.notes ?? ""
        ]);
      }

      final csvData = const ListToCsvConverter().convert(rows);
      final directory = await getTemporaryDirectory();
      final file = File('${directory.path}/inventory_export.csv');

      await file.writeAsString(csvData);

      logger.log("Export: CSV file written to ${file.path}. Total rows: ${rows.length}");

      await Share.shareXFiles([XFile(file.path)], text: 'Inventory CSV Export');
      logger.log("Export: CSV Share sheet closed.");
    } catch (e) {
      logger.log("EXPORT ERROR (CSV)", error: e);
      rethrow;
    }
  }
}

============================================================
PATH: .\lib\services\logger_service.dart
============================================================

import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class LoggerService {
  // Singleton pattern
  static final LoggerService _instance = LoggerService._internal();
  factory LoggerService() => _instance;
  LoggerService._internal();

  final List<String> _logs = [];
  List<String> get logs => List.unmodifiable(_logs);

  void log(String message, {dynamic error, StackTrace? stack}) {
    final timestamp = DateFormat('HH:mm:ss').format(DateTime.now());
    final logEntry = "[$timestamp] $message ${error ?? ''}";

    _logs.insert(0, logEntry); // Newest first
    debugPrint(logEntry); // Still print to console

    if (stack != null) {
      _logs.insert(0, "STACKTRACE: ${stack.toString().split('\n').take(3).join('\n')}");
    }

    // Keep only the last 100 logs to save memory
    if (_logs.length > 100) _logs.removeRange(100, _logs.length);
  }

  void clear() => _logs.clear();
}

final logger = LoggerService();

============================================================
PATH: .\lib\services\pdf_service.dart
============================================================

import 'dart:io';
import 'package:intl/intl.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../models/item.dart';
import '../providers/settings_provider.dart';
import '../services/logger_service.dart';

class PdfService {
  // SAFETY LIMIT: 3MB per image.
  // If an image is larger, we skip it to prevent App Crash (OOM).
  static const int _maxImageBytes = 3 * 1024 * 1024;

  static Future<void> generateInventoryReport(List<Item> items, SettingsProvider settings) async {
    logger.log("PDF: Starting report generation for ${items.length} items...");

    try {
      final pdf = pw.Document();
      final NumberFormat currencyFormat = NumberFormat.simpleCurrency();
      final DateTime now = DateTime.now();

      // 1. Calculate Summary Data
      double totalValue = items.fold(0, (sum, item) => sum + item.value);

      // --- PAGE 1: COVER & SUMMARY ---
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          margin: const pw.EdgeInsets.all(32),
          build: (context) => [
            // Header
            pw.Row(
              mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
              crossAxisAlignment: pw.CrossAxisAlignment.start,
              children: [
                pw.Column(
                  crossAxisAlignment: pw.CrossAxisAlignment.start,
                  children: [
                    pw.Text(
                      settings.userName.isEmpty ? "HOME INVENTORY REPORT" : settings.userName.toUpperCase(),
                      style: pw.TextStyle(fontSize: 18, fontWeight: pw.FontWeight.bold),
                    ),
                    if (settings.address.isNotEmpty)
                      pw.Padding(
                        padding: const pw.EdgeInsets.only(top: 2),
                        child: pw.Text(settings.address, style: const pw.TextStyle(fontSize: 10)),
                      ),
                    pw.SizedBox(height: 8),
                    pw.Text("INSURER: ${settings.insuranceCompany.isEmpty ? 'NOT SPECIFIED' : settings.insuranceCompany.toUpperCase()}", style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold)),
                    pw.Text("POLICY #: ${settings.policyNumber.isEmpty ? 'N/A' : settings.policyNumber}", style: pw.TextStyle(fontSize: 10, fontWeight: pw.FontWeight.bold)),
                    pw.SizedBox(height: 4),
                    pw.Text("Generated on: ${DateFormat.yMMMMd().format(now)}", style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey700)),
                  ],
                ),
                pw.Container(
                  padding: const pw.EdgeInsets.all(12),
                  decoration: const pw.BoxDecoration(color: PdfColors.grey100, borderRadius: pw.BorderRadius.all(pw.Radius.circular(4))),
                  child: pw.Column(
                    children: [
                      pw.Text("TOTAL ESTIMATED VALUE", style: const pw.TextStyle(fontSize: 8)),
                      pw.Text(currencyFormat.format(totalValue), style: pw.TextStyle(fontSize: 18, fontWeight: pw.FontWeight.bold, color: PdfColors.green900)),
                    ],
                  ),
                ),
              ],
            ),
            pw.SizedBox(height: 20),
            pw.Divider(thickness: 0.5, color: PdfColors.grey400),
            pw.SizedBox(height: 10),

            pw.Text("Inventory Overview", style: pw.TextStyle(fontSize: 16, fontWeight: pw.FontWeight.bold)),
            pw.SizedBox(height: 10),

            // Summary Table
            pw.Table.fromTextArray(
              headerStyle: pw.TextStyle(fontWeight: pw.FontWeight.bold, color: PdfColors.white),
              headerDecoration: const pw.BoxDecoration(color: PdfColors.blueGrey900),
              cellHeight: 25,
              columnWidths: {
                0: const pw.FlexColumnWidth(3),
                1: const pw.FlexColumnWidth(2),
                2: const pw.FlexColumnWidth(2),
                3: const pw.FlexColumnWidth(2),
              },
              headers: ['Item Name', 'Location', 'Purchase Date', 'Value'],
              data: items.map((item) => [
                item.name,
                "${item.room ?? 'N/A'}\n(${item.category ?? 'N/A'})",
                DateFormat.yMMMd().format(item.purchaseDate),
                currencyFormat.format(item.value),
              ]).toList(),
            ),
          ],
        ),
      );

      // --- APPENDIX: PHOTO EVIDENCE GRID ---
      logger.log("PDF: Processing image appendix...");
      pdf.addPage(
        pw.MultiPage(
          pageFormat: PdfPageFormat.a4,
          build: (context) => [
            pw.Header(level: 0, text: "Photo Evidence Appendix"),
            pw.SizedBox(height: 10),
            pw.GridView(
              crossAxisCount: 2,
              childAspectRatio: 0.8,
              children: items.map((item) {
                return pw.Container(
                  padding: const pw.EdgeInsets.all(5),
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Expanded(
                        // SAFE LOAD: Checks size before reading bytes
                        child: item.imagePaths.isNotEmpty
                            ? _safeLoadImage(item.imagePaths[0], item.name)
                            : pw.Container(color: PdfColors.grey300),
                      ),
                      pw.SizedBox(height: 5),
                      pw.Text(item.name, style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
                      pw.Text("${item.room ?? 'General'} | ${currencyFormat.format(item.value)}", style: const pw.TextStyle(fontSize: 8)),
                    ],
                  ),
                );
              }).toList(),
            ),
          ],
        ),
      );

      // --- HIGH VALUE DETAIL PAGES ---
      final highValueItems = items.where((i) => i.value >= 1000).toList();
      if (highValueItems.isNotEmpty) {
        logger.log("PDF: Generating ${highValueItems.length} high-value detail pages.");
        for (var item in highValueItems) {
          pdf.addPage(
            pw.Page(
              build: (context) => pw.Column(
                crossAxisAlignment: pw.CrossAxisAlignment.start,
                children: [
                  pw.Header(level: 0, text: "High Value Asset: ${item.name}"),
                  pw.Row(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      pw.Expanded(
                        flex: 1,
                        child: pw.Column(
                          crossAxisAlignment: pw.CrossAxisAlignment.start,
                          children: [
                            _detailRow("Value", currencyFormat.format(item.value)),
                            _detailRow("Brand", item.brand ?? "N/A"),
                            _detailRow("Model", item.model ?? "N/A"),
                            _detailRow("Serial #", item.serialNumber ?? "N/A"),
                            _detailRow("Purchase Date", DateFormat.yMMMMd().format(item.purchaseDate)),
                          ],
                        ),
                      ),
                      pw.SizedBox(width: 20),
                      pw.Expanded(
                        flex: 1,
                        child: item.imagePaths.isNotEmpty
                            ? _safeLoadImage(item.imagePaths[0], "Detail: ${item.name}")
                            : pw.Container(),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          );
        }
      }

      logger.log("PDF: Document complete. sending to print spooler...");
      await Printing.layoutPdf(onLayout: (PdfPageFormat format) async => pdf.save());

    } catch (e) {
      logger.log("CRITICAL PDF ERROR", error: e);
      rethrow;
    }
  }

  /// CRITICAL FIX: Safe Image Loader
  /// 1. Checks file existence
  /// 2. Checks file size (prevents OOM crashes)
  /// 3. Returns placeholder if unsafe
  static pw.Widget _safeLoadImage(String imagePath, String itemName) {
    try {
      final file = File(imagePath);

      if (!file.existsSync()) {
        logger.log("PDF Warning: Image missing for $itemName");
        return pw.Container(color: PdfColors.grey300, child: pw.Center(child: pw.Text("Missing File", style: const pw.TextStyle(fontSize: 8))));
      }

      // SIZE GUARD: Prevent OOM (Out Of Memory)
      final size = file.lengthSync();
      if (size > _maxImageBytes) {
        logger.log("PDF Warning: Image for $itemName is too large (${(size/1024/1024).toStringAsFixed(2)}MB). Skipping to save RAM.");
        return pw.Container(
          color: PdfColors.grey200,
          child: pw.Center(
              child: pw.Text(
                  "Image Too Large\nfor Report",
                  textAlign: pw.TextAlign.center,
                  style: const pw.TextStyle(fontSize: 8, color: PdfColors.grey700)
              )
          ),
        );
      }

      // Safe to load
      return pw.Image(
        pw.MemoryImage(file.readAsBytesSync()),
        fit: pw.BoxFit.cover,
      );

    } catch (e) {
      logger.log("PDF Error processing $itemName", error: e);
      return pw.Container(color: PdfColors.red100, child: pw.Center(child: pw.Text("Error", style: const pw.TextStyle(fontSize: 8))));
    }
  }

  static pw.Widget _detailRow(String label, String value) {
    return pw.Padding(
      padding: const pw.EdgeInsets.symmetric(vertical: 2),
      child: pw.RichText(
        text: pw.TextSpan(
          children: [
            pw.TextSpan(text: "$label: ", style: pw.TextStyle(fontWeight: pw.FontWeight.bold, fontSize: 10)),
            pw.TextSpan(text: value, style: const pw.TextStyle(fontSize: 10)),
          ],
        ),
      ),
    );
  }
}

============================================================
PATH: .\lib\services\zip_service.dart
============================================================

import 'dart:io';
// CRITICAL: Must use archive_io.dart to access disk streaming (InputFileStream)
import 'package:archive/archive_io.dart';
import 'package:path/path.dart' as p;
import 'package:path_provider/path_provider.dart';
import 'package:sqflite/sqflite.dart';
import '../services/logger_service.dart';
import '../data/database_helper.dart';

class ZipService {
  static Future<String> _getDatabasePath() async {
    final dbFolder = await getDatabasesPath();
    return p.join(dbFolder, 'inventory.db');
  }

  /// The main method used by your UI/Provider to create a .zip backup
  /// USES STREAMING to prevent Memory Crashes (OOM)
  static Future<File?> createFullBackup(List<String> allImagePaths) async {
    logger.log("Backup: Starting ZIP creation (Streaming Mode)...");

    try {
      final tempDir = await getTemporaryDirectory();
      final zipPath = p.join(tempDir.path, 'inventory_backup.zip');

      // 1. Initialize the Streaming Encoder
      // ZipFileEncoder streams data from disk to zip. It does NOT load files to RAM.
      final encoder = ZipFileEncoder();
      encoder.create(zipPath);

      // 2. Add the Database File
      final dbFilePath = await _getDatabasePath();
      final dbFile = File(dbFilePath);

      if (dbFile.existsSync()) {
        // encoder.addFile() uses InputFileStream internally.
        // This is safe even if the DB is 500MB.
        encoder.addFile(dbFile);
        logger.log("Backup: Database file streamed to ZIP.");
      } else {
        logger.log("Backup ERROR: Database file not found at $dbFilePath");
      }

      // 3. Add Images
      int imageCount = 0;
      for (String path in allImagePaths) {
        if (path.isEmpty) continue;

        final imgFile = File(path);
        if (imgFile.existsSync()) {
          // This streams the image file into the zip under the 'images' folder.
          // We DO NOT call readAsBytes() here.
          encoder.addFile(imgFile, 'images/${p.basename(path)}');
          imageCount++;
        } else {
          logger.log("Backup Warning: Skipping missing image at $path");
        }
      }

      // Finalize the zip file
      encoder.close();

      final finalFile = File(zipPath);
      final sizeMB = (await finalFile.length() / (1024 * 1024)).toStringAsFixed(2);

      logger.log("Backup: Success! Added $imageCount images. Total size: $sizeMB MB");
      return finalFile;
    } catch (e) {
      logger.log("CRITICAL BACKUP FAILURE", error: e);
      return null;
    }
  }

  /// Restores database and images from a selected .zip file
  static Future<bool> importBackup(File zipFile) async {
    logger.log("Import: Starting restoration from ${zipFile.path}");

    try {
      // NOTE: For extremely large backups on low-RAM devices, even reading the directory
      // via decodeBytes can be heavy. However, standard ZipDecoder is usually safe for <200MB.
      // A true streaming decoder would require a more complex implementation, but this
      // is sufficient for 99% of use cases.
      final bytes = await zipFile.readAsBytes();
      final archive = ZipDecoder().decodeBytes(bytes);

      final appDir = await getApplicationDocumentsDirectory();
      final dbPath = await _getDatabasePath();

      int filesRestored = 0;

      for (final file in archive) {
        final filename = file.name;
        if (file.isFile) {
          final data = file.content as List<int>;

          if (filename == 'inventory.db') {
            logger.log("Import: Detected database file. Closing active connection...");

            // 1. CRITICAL: Close the open DB connection to release the file lock
            await DatabaseHelper.instance.close();

            // 2. Handle Database Restore
            final tempDb = File('$dbPath.tmp');
            await tempDb.writeAsBytes(data);

            // 3. Delete old and rename new
            final oldDb = File(dbPath);
            if (await oldDb.exists()) {
              await oldDb.delete();
            }
            await tempDb.rename(dbPath);
            logger.log("Import: Database successfully replaced.");
          } else {
            // Handle Images Restore
            final outFile = File(p.join(appDir.path, filename));

            // Ensure directory exists
            await outFile.parent.create(recursive: true);
            await outFile.writeAsBytes(data);
            filesRestored++;
          }
        }
      }

      logger.log("Import: SUCCESS. Restored database and $filesRestored images.");
      return true;
    } catch (e) {
      logger.log("IMPORT FAILURE", error: e);
      return false;
    }
  }
}

============================================================
PATH: .\lib\utils\app_constants.dart
============================================================

class AppConstants {
  static const List<String> defaultRooms = [
    'Living Room',
    'Kitchen',
    'Bedroom',
    'Garage',
    'Office',
    'Basement',
    'Attic',
    'Dining Room'
  ];

  static const List<String> defaultCategories = [
    'Electronics',
    'Furniture',
    'Jewelry',
    'Tools',
    'Appliances',
    'Clothing',
    'Musical Instruments',
    'Collectibles'
  ];
}

============================================================
PATH: .\lib\widgets\barcode_scanner.dart
============================================================

import 'package:flutter/material.dart';
import 'package:mobile_scanner/mobile_scanner.dart';
import '../services/logger_service.dart';

class BarcodeScannerWidget extends StatefulWidget {
  const BarcodeScannerWidget({super.key});

  @override
  State<BarcodeScannerWidget> createState() => _BarcodeScannerWidgetState();
}

class _BarcodeScannerWidgetState extends State<BarcodeScannerWidget> {
  // MobileScannerController allows us to control the flash or switch cameras
  MobileScannerController cameraController = MobileScannerController();

  @override
  void dispose() {
    cameraController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Scan Serial Number'),
        actions: [
          // Flashlight toggle
          IconButton(
            icon: ValueListenableBuilder(
              valueListenable: cameraController,
              builder: (context, state, child) {
                switch (state.torchState) {
                  case TorchState.off:
                    return const Icon(Icons.flash_off, color: Colors.grey);
                  case TorchState.on:
                    return const Icon(Icons.flash_on, color: Colors.yellow);
                  case TorchState.auto:
                    return const Icon(Icons.flash_auto, color: Colors.blueAccent);
                  case TorchState.unavailable:
                    return const Icon(Icons.flash_off, color: Colors.black26);
                }
              },
            ),
            onPressed: () => cameraController.toggleTorch(),
          ),
        ],
      ),
      body: MobileScanner(
        controller: cameraController,
        onDetect: (BarcodeCapture capture) {
          final List<Barcode> barcodes = capture.barcodes;
          if (barcodes.isNotEmpty) {
            final String code = barcodes.first.rawValue ?? "Unknown";

            // Log the successful scan
            logger.log("Barcode Scanned successfully: $code");

            Navigator.pop(context, code);
          } else {
            logger.log("Scanner triggered but no barcode data detected.");
          }
        },
      ),
    );
  }
}

============================================================
PATH: .\test\widget_test.dart
============================================================

